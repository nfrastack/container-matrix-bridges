#!/command/with-contenv bash

bootstrap_filesystem() {
    if [ ! -d "${CONFIG_PATH}" ] ; then
        mkdir -p "${CONFIG_PATH}"
    fi
    if [ $(stat -c %U "${CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${CONFIG_PATH}" ; fi

    if [ ! -d "${DATA_PATH}" ] ; then
        mkdir -p "${DATA_PATH}"
    fi
    if [ $(stat -c %U "${DATA_PATH}") != "matrix" ] ; then chown matrix:matrix "${DATA_PATH}" ; fi

    if [ ! -d "${LOG_PATH}" ] ; then
        mkdir -p "${LOG_PATH}"
    fi
    if [ $(stat -c %U "${LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${LOG_PATH}" ; fi
    create_logrotate matrix_bridges "${LOG_PATH}"/*.log matrix matrix

    if [ ! -d "${REGISTRATION_PATH}" ] ; then
        mkdir -p "${REGISTRATION_PATH}"
    fi
    if [ $(stat -c %U "${REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${REGISTRATION_PATH}" ; fi
}

configure_discord2() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_discord
        set +a
        print_debug "[configure_discord]"

        if [ ! -d "${DISCORD_CONFIG_PATH}" ] ; then
            mkdir -p "${DISCORD_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_CONFIG_PATH}" ; fi

        if [ ! -d "${DISCORD_REGISTRATION_PATH}" ] ; then
            mkdir -p "${DISCORD_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_REGISTRATION_PATH}" ; fi

        if [ ! -d "${DISCORD_LOG_PATH}" ] ; then
            mkdir -p "${DISCORD_LOG_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_LOG_PATH}" ; fi

        case "${DISCORD_DB_TYPE,,}" in
            postgres* )
                sanity_var DISCORD_DB_USER "DB Username for Signal"
                sanity_var DISCORD_DB_PASS "DB Password for Signal"
                sanity_var DISCORD_DB_HOST "DB Host for Signal"
                sanity_var DISCORD_DB_NAME "DB Name for Signal"
                counter=0
                export PGPASSWORD=${DISCORD_DB_PASS}
                until pg_isready --dbname="${DISCORD_DB_NAME}" --host="${DISCORD_DB_HOST}" --port="${DISCORD_DB_PORT}" --username="${DISCORD_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${DISCORD_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export DISCORD_DB_TYPE="postgres"
                export DISCORD_DB_STRING=${DISCORD_DB_STRING:-"postgres://${DISCORD_DB_USER}:${DISCORD_DB_PASS}@${DISCORD_DB_HOST}:${DISCORD_DB_PORT}/${DISCORD_DB_NAME}"}
            ;;
            sqlite* )
                if [ ! -d "${DISCORD_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${DISCORD_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${DISCORD_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_DB_SQLITE_PATH}" ; fi
                export DISCORD_DB_TYPE="sqlite-fk-wal"
                export DISCORD_DB_STRING=${DISCORD_DB_STRING:-"sqlite://${DISCORD_DB_SQLITE_PATH}/${DISCORD_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/discord/example.config.yaml "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(DISCORD_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(DISCORD_HOMESERVER_DOMAIN) |
                                        .homeserver.verify_ssl = env(DISCORD_HOMESERVER_TLS_VERIFY) |
                                        .homeserver.software = env(DISCORD_HOMESERVER_SOFTWARE) |
                                        .homeserver.http_retry_count = env(DISCORD_HOMESERVER_HTTP_RETRY_COUNT) |
                                        .homeserver.status_endpoint = env(DISCORD_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(DISCORD_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.connection_limit = env(DISCORD_HOMESERVER_CONNECTION_LIMIT) |
                                        .homeserver.async_media = env(DISCORD_HOMESERVER_ENABLE_ASYNC_UPLOADS) |
                                        .homeserver.ping_interval_seconds = env(DISCORD_HOMESERVER_PING_INTERVAL)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        s6-setuidgid matrix yq -i    '
                                        .appservice.address = env(DISCORD_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(DISCORD_LISTEN_IP) |
                                        .appservice.port = env(DISCORD_LISTEN_PORT) |
                                        .appservice.database.type = env(DISCORD_DB_TYPE) |
                                        .appservice.database.uri = env(DISCORD_DB_STRING) |
                                        .appservice.database.max_open_conns = env(DISCORD_DB_MAX_OPEN_CONNECTIONS) |
                                        .appservice.database.max_idle_conns = env(DISCORD_DB_MAX_IDLE_CONNECTIONS) |
                                        .appservice.id = env(DISCORD_APPSERVICE_ID) |
                                        .appservice.bot.username = env(DISCORD_BOT_USERNAME) |
                                        .appservice.bot.displayname = env(DISCORD_BOT_DISPLAYNAME) |
                                        .appservice.bot.avatar = env(DISCORD_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(DISCORD_ENABLE_EPHEMERAL_EVENTS)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"


        if [ -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" && [ -z "${DISCORD_AS_TOKEN}" ] ; then
            print_debug "[configure_discord] Setting as_token in configuration from previously generated registration file"
            export TOI_DISCORD_AS_TOKEN=$(yq '.as_token' "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_DISCORD_AS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            fbastokenskip=true
        elif [ -n "${DISCORD_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"; then
            print_notice "You've supplied 'DISCORD_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${DISCORD_AS_TOKEN}" ] ; then
            print_debug "[configure_discord] Updating DISCORD_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(DISCORD_AS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        if [ -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" && [ -z "${DISCORD_HS_TOKEN}" ] ; then
            print_debug "[configure_discord] Setting hs_token in configuration from previously generated registration file"
            export TOI_DISCORD_HS_TOKEN=$(yq '.hs_token' "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_DISCORD_HS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            fbhstokenskip=true
        elif [ -n "${DISCORD_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"; then
            print_notice "You've supplied 'DISCORD_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${DISCORD_HS_TOKEN}" ] ; then
            print_debug "[configure_discord] Updating DISCORD_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(DISCORD_HS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(DISCORD_ENABLE_METRICS) |
                                        .metrics.listen_port = env(DISCORD_METRICS_LISTEN_PORT)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        if var_true "${DISCORD_CONFIGURE_BRIDGE}" ; then
            # TODO
            # .bridge.message_handling_timeout
            # .bridge.login_shared_secret_map + double_puppet
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(DISCORD_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(DISCORD_TEMPLATE_DISPLAYNAME) |
                                            .bridge.private_chat_portal_discord = env(DISCORD_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.use_contact_avatars = env(DISCORD_USE_CONTACT_AVATARS) |
                                            .bridge.number_in_topic = env(DISCORD_INCLUDE_NUMBER_IN_TOPIC) |
                                            .bridge.note_to_self_avatar = env(DISCORD_NOTE_TO_SELF_AVATAR) |
                                            .bridge.portal_message_buffer = env(DISCORD_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.personal_filtering_spaces = env(DISCORD_PERSONAL_FILTERING_SPACES) |
                                            .bridge.bridge_notices = env(DISCORD_BRIDGE_NOTICES) |
                                            .bridge.delivery_receipts = env(DISCORD_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(DISCORD_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(DISCORD_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.sync_direct_chat_list = env(DISCORD_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.resend_bridge_info = env(DISCORD_RESEND_BRIDGE_INFO) |
                                            .bridge.public_portals = env(DISCORD_PUBLIC_PORTALS) |
                                            .bridge.caption_in_message = env(DISCORD_CAPTION_IN_MESSAGE) |
                                            .bridge.federate_rooms = env(DISCORD_FEDERATE_ROOMS) |
                                            .bridge.double_puppet_allow_discovery = env(DISCORD_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.command_prefix = "'$(echo ${DISCORD_COMMAND_PREFIX})'" |
                                            .bridge.management_room_text.welcome = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            .bridge.management_room_text.welcome_connected = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME_CONNECTED) |
                                            .bridge.management_room_text.welcome_unconnected = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME_UNCONNECTED) |
                                            .bridge.management_room_text.additional_help = "'$(echo ${DISCORD_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP})'" |
                                            .bridge.encryption.allow = env(DISCORD_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(DISCORD_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(DISCORD_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(DISCORD_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(DISCORD_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(DISCORD_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(DISCORD_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(DISCORD_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        set -f

        if [ -n "${DISCORD_PERMISSIONS_RELAY}" ] ; then
            discordrelays=$(echo "${DISCORD_PERMISSIONS_RELAY}" | tr "," "\n")
            for discordrelay in $discordrelays; do
                if [ "$discordrelay" = "*" ] ; then
                    export SIGNALRELAY="PLACEHOLDERASTERISK"
                else
                    export SIGNALRELAY=$discordrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${SIGNALRELAY})'" ]+= "relay"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi

        if [ -n "${DISCORD_PERMISSIONS_ADMIN}" ] ; then
            discordadmins=$(echo "${DISCORD_PERMISSIONS_ADMIN}" | tr "," "\n")
            for discordadmin in $discordadmins; do
                if [ "$discordadmin" = "*" ] ; then
                    export SIGNALADMIN="PLACEHOLDERASTERISK"
                else
                    export SIGNALADMIN=$discordadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${SIGNALADMIN})'" ] += "admin"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi

        if [ -n "${DISCORD_PERMISSIONS_USER}" ] ; then
            discordusers=$(echo "${DISCORD_PERMISSIONS_USER}" | tr "," "\n")
            for discorduser in $discordusers; do
                if [ "$discorduser" = "*" ] ; then
                    export SIGNALUSER="PLACEHOLDERASTERISK"
                else
                    export SIGNALUSER=$discorduser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(SIGNALUSER)] += "user"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.logging)' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        yq -i '.logging.min_level = env(DISCORD_LOG_LEVEL)' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        case "${DISCORD_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_discord "${DISCORD_LOG_PATH}"/"${DISCORD_LOG_FILE}" bridge_ matrix matrixdiscord
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            },
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${DISCORD_LOG_PATH}/${DISCORD_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            ;;
            "console" )
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            }
                        ]
                      ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            ;;
            "file" )
                create_logrotate bridge_discord "${DISCORD_LOG_PATH}"/"${DISCORD_LOG_FILE}" bridge_ matrix matrixdiscord
                yq -i '
                        .logging.writers = [
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${DISCORD_LOG_PATH}/${DISCORD_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            ;;
        esac

        if [ ! -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_discord] Didn't find a registration file. Generating to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        elif var_true "${DISCORD_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_discord] Regenerating registration file to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        elif var_true "${discord_force_registration}" ; then
            print_notice "[configure_discord] Something has changed  - Force generating registration file to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        fi

        if var_true "${discord_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${DISCORD_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_discord \
                                                        -g \
                                                        -c "${DISCORD_CONFIG_PATH}"/${DISCORD_CONFIG_FILE} \
                                                        -r "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_discord] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_discord() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_discord
        set +a
        print_debug "[configure_discord]"

        if [ ! -d "${DISCORD_CONFIG_PATH}" ] ; then
            mkdir -p "${DISCORD_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_CONFIG_PATH}" ; fi

        if [ ! -d "${DISCORD_REGISTRATION_PATH}" ] ; then
            mkdir -p "${DISCORD_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_REGISTRATION_PATH}" ; fi

        if [ ! -d "${DISCORD_LOG_PATH}" ] ; then
            mkdir -p "${DISCORD_LOG_PATH}"
        fi
        if [ $(stat -c %U "${DISCORD_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_LOG_PATH}" ; fi

        case "${DISCORD_DB_TYPE,,}" in
            postgres* )
                sanity_var DISCORD_DB_USER "DB Username for Discord"
                sanity_var DISCORD_DB_PASS "DB Password for Discord"
                sanity_var DISCORD_DB_HOST "DB Host for Discord"
                sanity_var DISCORD_DB_NAME "DB Name for Discord"
                counter=0
                export PGPASSWORD=${DISCORD_DB_PASS}
                until pg_isready --dbname="${DISCORD_DB_NAME}" --host="${DISCORD_DB_HOST}" --port="${DISCORD_DB_PORT}" --username="${DISCORD_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${DISCORD_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                if var_true "${DISCORD_DB_ENABLE_TLS}" ; then
                    discord_db_tls="?sslmode=enable"
                else
                    discord_db_tls="?sslmode=disable"
                fi
                export DISCORD_DB_TYPE=postgres
                export DISCORD_DB_STRING=${DISCORD_DB_STRING:-"postgres://${DISCORD_DB_USER}:${DISCORD_DB_PASS}@${DISCORD_DB_HOST}:${DISCORD_DB_PORT}/${DISCORD_DB_NAME}${discord_db_tls}"}
            ;;
            sqlite* )
                if [ ! -d "${DISCORD_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${DISCORD_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${DISCORD_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${DISCORD_DB_SQLITE_PATH}" ; fi
                export DISCORD_DB_TYPE=sqlite-fk-wal
                export DISCORD_DB_STRING=${DISCORD_DB_STRING:-"file://${DISCORD_DB_SQLITE_PATH}/${DISCORD_DB_SQLITE_FILE}?_txlock=immediate"}
            ;;
        esac

        if [ ! -f "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/discord/example.config.yaml "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(DISCORD_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(DISCORD_HOMESERVER_DOMAIN) |
                                        .homeserver.software = env(DISCORD_HOMESERVER_SOFTWARE) |
                                        .homeserver.status_endpoint = env(DISCORD_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(DISCORD_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.async_media = env(DISCORD_HOMESERVER_ENABLE_ASYNC_UPLOADS)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        s6-setuidgid matrix yq -i    '
                                        .appservice.address = env(DISCORD_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(DISCORD_LISTEN_IP) |
                                        .appservice.port = env(DISCORD_LISTEN_PORT) |
                                        .appservice.database.type = env(DISCORD_DB_TYPE) |
                                        .appservice.database.uri = env(DISCORD_DB_STRING) |
                                        .appservice.database.max_open_conns = env(DISCORD_DB_CONNECTIONS_MAX_OPEN) |
                                        .appservice.database.max_idle_conns = env(DISCORD_DB_CONNECTIONS_MAX_IDLE) |
                                        .appservice.database.max_conn_idle_time = env(DISCORD_DB_CONNECTIONS_MAX_IDLE_LIFETIME) |
                                        .appservice.database.max_conn_lifetime = env(DISCORD_DB_CONNECTIONS_MAX_LIFETIME) |
                                        .appservice.id = env(DISCORD_APPSERVICE_ID) |
                                        .appservice.bot_username = env(DISCORD_BOT_USERNAME) |
                                        .appservice.bot_displayname = env(DISCORD_BOT_DISPLAYNAME) |
                                        .appservice.bot_avatar = env(DISCORD_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(DISCORD_ENABLE_EPHEMERAL_EVENTS) |
                                        .appservice.async_transactions = env(DISCORD_ENABLE_ASYNC_TRANSACTIONS)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"


        if [ -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" && [ -z "${DISCORD_AS_TOKEN}" ] ; then
            print_debug "[configure_discord] Setting as_token in configuration from previously generated registration file"
            export TOI_DISCORD_AS_TOKEN=$(yq '.as_token' "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_DISCORD_AS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            waastokenskip=true
        elif [ -n "${DISCORD_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"; then
            print_notice "You've supplied 'DISCORD_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${DISCORD_AS_TOKEN}" ] ; then
            print_debug "[configure_discord] Updating DISCORD_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(DISCORD_AS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        if [ -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" && [ -z "${DISCORD_HS_TOKEN}" ] ; then
            print_debug "[configure_discord] Setting hs_token in configuration from previously generated registration file"
            export TOI_DISCORD_HS_TOKEN=$(yq '.hs_token' "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_DISCORD_HS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            wahstokenskip=true
        elif [ -n "${DISCORD_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"; then
            print_notice "You've supplied 'DISCORD_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${DISCORD_HS_TOKEN}" ] ; then
            print_debug "[configure_discord] Updating DISCORD_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(DISCORD_HS_TOKEN)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(DISCORD_ENABLE_METRICS) |
                                        .metrics.listen = "'$(echo ${DISCORD_METRICS_LISTEN_IP}:${DISCORD_METRICS_LISTEN_PORT})'"
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .segment_key = env(DISCORD_SEGMENT_API_KEY)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

       s6-setuidgid matrix yq -i    '
                                        .discord.os_name = env(DISCORD_OS_NAME) |
                                        .discord.browser_name = env(DISCORD_BROWSER_NAME)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        if var_true "${DISCORD_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = env(DISCORD_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(DISCORD_TEMPLATE_DISPLAYNAME) |
                                            .bridge.guild_name_template = env(DISCORD_TEMPLATE_GUILDNAME) |
                                            .bridge.channel_name_template = strenv(DISCORD_TEMPLATE_CHANNELNAME) |
                                            .bridge.private_chat_portal_meta = env(DISCORD_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.portal_message_buffer = env(DISCORD_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.startup_private_channel_create_limit = env(DISCORD_STARTUP_PRIVATE_CHANNEL_CREATE_LIMIT) |
                                            .bridge.delivery_receipts = env(DISCORD_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(DISCORD_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(DISCORD_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.restricted_rooms = env(DISCORD_RESTRICTED_ROOMS) |
                                            .bridge.autojoin_thread_on_open = env(DISCORD_AUTOJOIN_THREAD_ON_OPEN) |
                                            .bridge.sync_direct_chat_list = env(DISCORD_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.resend_bridge_info = env(DISCORD_RESEND_BRIDGE_INFO) |
                                            .bridge.delete_portal_on_channel_delete = env(DISCORD_) |
                                            .bridge.federate_rooms = env(DISCORD_FEDERATE_ROOMS) |
                                            .bidge.double_puppet_allow_discovery = env(DISCORD_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.management_room_text.welcome = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            .bridge.management_room_text.welcome_connected = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME_CONNECTED) |
                                            .bridge.management_room_text.welcome_unconnected = env(DISCORD_MANAGEMENT_ROOM_TEXT_WELCOME_UNCONNECTED) |
                                            .bridge.management_room_text.additional_help = env(DISCORD_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP) |
                                            .bridge.provisioning.prefix = env(DISCORD_PROVISIONING_PREFIX) |
                                            .bridge.command_prefix = "'$(echo ${DISCORD_COMMAND_PREFIX})'" |
                                            .bridge.encryption.allow = env(DISCORD_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(DISCORD_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(DISCORD_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(DISCORD_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(DISCORD_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(DISCORD_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(DISCORD_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(DISCORD_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(DISCORD_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        set -f

        if [ -n "${DISCORD_PERMISSIONS_RELAY}" ] ; then
            discordrelays=$(echo "${DISCORD_PERMISSIONS_RELAY}" | tr "," "\n")
            for discordrelay in $discordrelays; do
                if [ "$discordrelay" = "*" ] ; then
                    export DISCORDRELAY="PLACEHOLDERASTERISK"
                else
                    export DISCORDRELAY=$discordrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${DISCORDRELAY})'" ]+= "relay"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi

        if [ -n "${DISCORD_PERMISSIONS_ADMIN}" ] ; then
            discordadmins=$(echo "${DISCORD_PERMISSIONS_ADMIN}" | tr "," "\n")
            for discordadmin in $discordadmins; do
                if [ "$discordadmin" = "*" ] ; then
                    export DISCORDADMIN="PLACEHOLDERASTERISK"
                else
                    export DISCORDADMIN=$discordadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${DISCORDADMIN})'" ] += "admin"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi

        if [ -n "${DISCORD_PERMISSIONS_USER}" ] ; then
            discordusers=$(echo "${DISCORD_PERMISSIONS_USER}" | tr "," "\n")
            for discorduser in $discordusers; do
                if [ "$discorduser" = "*" ] ; then
                    export DISCORDUSER="PLACEHOLDERASTERISK"
                else
                    export DISCORDUSER=$discorduser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(DISCORDUSER)] += "user"
                                            ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"
        fi

        case "${DISCORD_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_discord "${DISCORD_LOG_PATH}"/"${DISCORD_LOG_FILE}" matrix matrix bridge_discord
                export DISCORD_LOG_TYPE="console,file"
            ;;
            "console" )
                export DISCORD_LOG_TYPE="console"
                export DISCORD_LOG_FILE="null"
            ;;
            "file" )
                create_logrotate bridge_discord "${DISCORD_LOG_PATH}"/"${DISCORD_LOG_FILE}" bridge_matrix matrix
                export DISCORD_LOG_TYPE="file"
            ;;
        esac

        s6-setuidgid matrix yq -i   '
                                        .logging.directory = "'$(echo "${DISCORD_LOG_PATH}")'" |
                                        .logging.file_name_format = env(DISCORD_LOG_FILE) |
                                        .logging.file_mode = "644" |
                                        .logging.timestamp_format = "2006-01-02 15:04:05" |
                                        .logging.print_level = env(DISCORD_LOG_LEVEL) |
                                        .logging.print_json = env(DISCORD_LOG_CONSOLE_JSON) |
                                        .logging.file_json = env(DISCORD_LOG_FILE_JSON)
                                    ' "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}"

        create_logrotate bridge_discord "${DISCORD_LOG_PATH}"/"${DISCORD_LOG_FILE}" bridge_ matrix matrixdiscord

        if [ ! -f "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_discord] Didn't find a registration file. Generating to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        elif var_true "${DISCORD_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_discord] Regenerating registration file to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        elif var_true "${discord_force_registration}" ; then
            print_notice "[configure_discord] Something has changed  - Force generating registration file to '${DISCORD_REGISTRATION_PATH}/${DISCORD_REGISTRATION_FILE}'"
            discord_generate_registration=true
        fi

        if var_true "${discord_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${DISCORD_REGISTRATION_PATH}"
            silent s6-setuidgid matrix mautrix-discord \
                                                    -g \
                                                    -c "${DISCORD_CONFIG_PATH}"/"${DISCORD_CONFIG_FILE}" \
                                                    -r "${DISCORD_REGISTRATION_PATH}"/"${DISCORD_REGISTRATION_FILE}" \
                                                    || exit $?
            print_notice "[configure_discord] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_facebook() {
        if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_facebook
        set +a
        print_debug "[configure_meta]"

        if [ ! -d "${FACEBOOK_CONFIG_PATH}" ] ; then
            mkdir -p "${FACEBOOK_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${FACEBOOK_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${FACEBOOK_CONFIG_PATH}" ; fi

        if [ ! -d "${FACEBOOK_REGISTRATION_PATH}" ] ; then
            mkdir -p "${FACEBOOK_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${FACEBOOK_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${FACEBOOK_REGISTRATION_PATH}" ; fi

        if [ ! -d "${FACEBOOK_LOG_PATH}" ] ; then
            mkdir -p "${FACEBOOK_LOG_PATH}"
        fi
        if [ $(stat -c %U "${FACEBOOK_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${FACEBOOK_LOG_PATH}" ; fi

        case "${FACEBOOK_DB_TYPE,,}" in
            postgres* )
                sanity_var FACEBOOK_DB_USER "DB Username for Facebook"
                sanity_var FACEBOOK_DB_PASS "DB Password for Facebook"
                sanity_var FACEBOOK_DB_HOST "DB Host for Facebook"
                sanity_var FACEBOOK_DB_NAME "DB Name for Facebook"
                counter=0
                export PGPASSWORD=${FACEBOOK_DB_PASS}
                until pg_isready --dbname="${FACEBOOK_DB_NAME}" --host="${FACEBOOK_DB_HOST}" --port="${FACEBOOK_DB_PORT}" --username="${FACEBOOK_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${FACEBOOK_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export FACEBOOK_DB_TYPE="postgres"
                export FACEBOOK_DB_STRING=${FACEBOOK_DB_STRING:-"postgres://${FACEBOOK_DB_USER}:${FACEBOOK_DB_PASS}@${FACEBOOK_DB_HOST}:${FACEBOOK_DB_PORT}/${FACEBOOK_DB_NAME}?sslmode=${FACEBOOK_DB_SSL_MODE,,}"}
            ;;
            sqlite* )
                if [ ! -d "${FACEBOOK_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${FACEBOOK_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${FACEBOOK_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${FACEBOOK_DB_SQLITE_PATH}" ; fi
                export FACEBOOK_DB_TYPE="sqlite-fk-wal"
                export FACEBOOK_DB_STRING=${FACEBOOK_DB_STRING:-"sqlite://${FACEBOOK_DB_SQLITE_PATH}/${FACEBOOK_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/facebook/example.config.yaml "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(FACEBOOK_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(FACEBOOK_HOMESERVER_DOMAIN) |
                                        .homeserver.software = env(FACEBOOK_HOMESERVER_SOFTWARE) |
                                        .homeserver.status_endpoint = env(FACEBOOK_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.async_media = env(FACEBOOK_HOMESERVER_ENABLE_ASYNC_UPLOADS) |
                                        .homeserver.ping_interval_seconds = env(FACEBOOK_HOMESERVER_PING_INTERVAL)
                                    ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(FACEBOOK_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(FACEBOOK_LISTEN_IP) |
                                        .appservice.port = env(FACEBOOK_LISTEN_PORT) |
                                        .appservice.database.type = env(FACEBOOK_DB_TYPE) |
                                        .appservice.database.uri = env(FACEBOOK_DB_STRING) |
                                        .appservice.database.max_open_conns = env(FACEBOOK_DB_MAX_OPEN_CONNECTIONS) |
                                        .appservice.database.max_idle_conns = env(FACEBOOK_DB_MAX_IDLE_CONNECTIONS) |
                                        .appservice.id = env(FACEBOOK_APPSERVICE_ID) |
                                        .appservice.bot.username = env(FACEBOOK_BOT_USERNAME) |
                                        .appservice.bot.displayname = env(FACEBOOK_BOT_DISPLAYNAME) |
                                        .appservice.bot.avatar = env(FACEBOOK_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(FACEBOOK_ENABLE_EPHEMERAL_EVENTS) |
                                        .appservice.async_transactions = env(FACEBOOK_ENABLE_ASYNC_TRANSACTIONS)
                                    ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"


        if [ -f "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}" && [ -z "${FACEBOOK_AS_TOKEN}" ] ; then
            print_debug "[configure_facebook] Setting as_token in configuration from previously generated registration file"
            export TOI_FACEBOOK_AS_TOKEN=$(yq '.as_token' "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_facebook_AS_TOKEN)
                                        ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            fbastokenskip=true
        elif [ -n "${FACEBOOK_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"; then
            print_notice "You've supplied 'FACEBOOK_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${FACEBOOK_AS_TOKEN}" ] ; then
            print_debug "[configure_facebook] Updating FACEBOOK_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(FACEBOOK_AS_TOKEN)
                                        ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        fi

        if [ -f "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}" && [ -z "${FACEBOOK_HS_TOKEN}" ] ; then
            print_debug "[configure_facebook] Setting hs_token in configuration from previously generated registration file"
            export TOI_FACEBOOK_HS_TOKEN=$(yq '.hs_token' "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_facebook_HS_TOKEN)
                                        ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        elif [ -n "${FACEBOOK_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"; then
            print_notice "You've supplied 'FACEBOOK_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${FACEBOOK_HS_TOKEN}" ] ; then
            print_debug "[configure_facebook] Updating FACEBOOK_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(FACEBOOK_HS_TOKEN)
                                        ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(FACEBOOK_ENABLE_METRICS) |
                                        .metrics.listen = env(FACEBOOK_METRICS_LISTEN_IP_PORT)
                                    ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .meta.mode = "facebook" |
                                        .meta.ig_e2ee = false
                                    ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"

        if var_true "${FACEBOOK_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(FACEBOOK_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(FACEBOOK_TEMPLATE_DISPLAYNAME) |
                                            .bridge.private_chat_portal_meta = env(FACEBOOK_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.portal_message_buffer = env(FACEBOOK_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.personal_filtering_spaces = env(FACEBOOK_PERSONAL_FILTERING_SPACES) |
                                            .bridge.bridge_notices = env(FACEBOOK_BRIDGE_NOTICES) |
                                            .bridge.delivery_receipts = env(FACEBOOK_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(FACEBOOK_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(FACEBOOK_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.disable_bridge_alerts = env(FACEBOOK_DISABLE_BRIDGE_NOTICES) |
                                            .bridge.sync_direct_chat_list = env(FACEBOOK_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.resend_bridge_info = env(FACEBOOK_RESEND_BRIDGE_INFO) |
                                            .bridge.caption_in_message = env(FACEBOOK_CAPTION_IN_MESSAGE) |
                                            .bridge.federate_rooms = env(FACEBOOK_FEDERATE_ROOMS) |
                                            .bridge.mute_bridging = env(FACEBOOK_MUTE_BRIDGING) |
                                            .bridge.double_puppet_allow_discovery = env(FACEBOOK_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.command_prefix = "'$(echo ${FACEBOOK_COMMAND_PREFIX})'" |
                                            .bridge.backfill.enabled = env(FACEBOOK_BRIDGE_BACKFILL_ENABLED) |
                                            .bridge.backfill.inbox_fetch_pages = env(FACEBOOK_BRIDGE_BACKFILL_INBOX_FETCH_PAGES) |
                                            .bridge.backfill.history_fetch_pages = env(FACEBOOK_BRIDGE_BACKFILL_HISTORY_FETCH_PAGES) |
                                            .bridge.backfill.catchup_fetch_pages = env(FACEBOOK_BRIDGE_BACKFILL_CATCHUP_FETCH_PAGES) |
                                            .bridge.backfill.unread_hours_threshold = env(FACEBOOK_BRIDGE_BACKFILL_UNREAD_HOURS_THRESHOLD) |
                                            .bridge.backfill.queue.pages_at_once = env(FACEBOOK_BRIDGE_BACKFILL_QUEUE_PAGES_AT_ONCE) |
                                            .bridge.backfill.queue.max_pages = env(FACEBOOK_BRIDGE_BACKFILL_QUEUE_MAX_PAGES) |
                                            .bridge.backfill.queue.sleep_between_tasks = env(FACEBOOK_BRIDGE_BACKFILL_QUEUE_SLEEP_BETWEEN_TASKS) |
                                            .bridge.backfill.queue.dont_fetch_xma = env(FACEBOOK_BRIDGE_BACKFILL_QUEUE_DONT_FETCH_XMA) |
                                            .bridge.management_room_text.welcome = env(FACEBOOK_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            .bridge.management_room_text.welcome_connected = env(FACEBOOK_MANAGEMENT_ROOM_TEXT_WELCOME_CONNECTED) |
                                            .bridge.management_room_text.welcome_unconnected = env(FACEBOOK_MANAGEMENT_ROOM_TEXT_WELCOME_UNCONNECTED) |
                                            .bridge.management_room_text.additional_help = "'$(echo ${FACEBOOK_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP})'" |
                                            .bridge.encryption.allow = env(FACEBOOK_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(FACEBOOK_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(FACEBOOK_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(FACEBOOK_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(FACEBOOK_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(FACEBOOK_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(FACEBOOK_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(FACEBOOK_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(FACEBOOK_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(FACEBOOK_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(FACEBOOK_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        set -f

        if [ -n "${FACEBOOK_PERMISSIONS_RELAY}" ] ; then
            facebookrelays=$(echo "${FACEBOOK_PERMISSIONS_RELAY}" | tr "," "\n")
            for facebookrelay in $facebookrelays; do
                if [ "$facebookrelay" = "*" ] ; then
                    export FACEBOOKRELAY="PLACEHOLDERASTERISK"
                else
                    export FACEBOOKRELAY=$facebookrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${FACEBOOKRELAY})'" ]+= "relay"
                                            ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            done
        fi

        if [ -n "${FACEBOOK_PERMISSIONS_ADMIN}" ] ; then
            facebookadmins=$(echo "${FACEBOOK_PERMISSIONS_ADMIN}" | tr "," "\n")
            for facebookadmin in $facebookadmins; do
                if [ "$facebookadmin" = "*" ] ; then
                    export FACEBOOKADMIN="PLACEHOLDERASTERISK"
                else
                    export FACEBOOKADMIN=$facebookadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${FACEBOOKADMIN})'" ] += "admin"
                                            ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            done
        fi

        if [ -n "${FACEBOOK_PERMISSIONS_USER}" ] ; then
            facebookusers=$(echo "${FACEBOOK_PERMISSIONS_USER}" | tr "," "\n")
            for facebookuser in $facebookusers; do
                if [ "$facebookuser" = "*" ] ; then
                    export FACEBOOKUSER="PLACEHOLDERASTERISK"
                else
                    export FACEBOOKUSER=$facebookuser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(FACEBOOKUSER)] += "user"
                                            ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        fi
        s6-setuidgid matrix yq -i 'del(.logging)' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        yq -i '.logging.min_level = env(FACEBOOK_LOG_LEVEL)' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
        case "${FACEBOOK_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_facebook "${FACEBOOK_LOG_PATH}"/"${FACEBOOK_LOG_FILE}" bridge_ matrix matrixfacebook
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            },
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${FACEBOOK_LOG_PATH}/${FACEBOOK_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            ;;
            "console" )
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            }
                        ]
                      ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            ;;
            "file" )
                create_logrotate bridge_facebook "${FACEBOOK_LOG_PATH}"/"${FACEBOOK_LOG_FILE}" bridge_ matrix matrixfacebook
                yq -i '
                        .logging.writers = [
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${FACEBOOK_LOG_PATH}/${FACEBOOK_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${FACEBOOK_CONFIG_PATH}"/"${FACEBOOK_CONFIG_FILE}"
            ;;
        esac

        if [ ! -f "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_facebook] Didn't find a registration file. Generating to '${FACEBOOK_REGISTRATION_PATH}/${FACEBOOK_REGISTRATION_FILE}'"
            facebook_generate_registration=true
        elif var_true "${FACEBOOK_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_facebook] Regenerating registration file to '${FACEBOOK_REGISTRATION_PATH}/${FACEBOOK_REGISTRATION_FILE}'"
            facebook_generate_registration=true
        elif var_true "${facebook_force_registration}" ; then
            print_notice "[configure_facebook] Something has changed  - Force generating registration file to '${FACEBOOK_REGISTRATION_PATH}/${FACEBOOK_REGISTRATION_FILE}'"
            facebook_generate_registration=true
        fi

        if var_true "${facebook_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${FACEBOOK_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_facebook \
                                                        -g \
                                                        -c "${FACEBOOK_CONFIG_PATH}"/${FACEBOOK_CONFIG_FILE} \
                                                        -r "${FACEBOOK_REGISTRATION_PATH}"/"${FACEBOOK_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_facebook] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_googlechat() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_googlechat
        set +a
        print_debug "[configure_googlechat]"
        if [ ! -d "${GOOGLECHAT_CONFIG_PATH}" ] ; then
            mkdir -p "${GOOGLECHAT_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${GOOGLECHAT_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${GOOGLECHAT_CONFIG_PATH}" ; fi

        if [ ! -d "${GOOGLECHAT_REGISTRATION_PATH}" ] ; then
            mkdir -p "${GOOGLECHAT_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${GOOGLECHAT_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${GOOGLECHAT_REGISTRATION_PATH}" ; fi

        if [ ! -d "${GOOGLECHAT_LOG_PATH}" ] ; then
            mkdir -p "${GOOGLECHAT_LOG_PATH}"
        fi
        if [ $(stat -c %U "${GOOGLECHAT_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${GOOGLECHAT_LOG_PATH}" ; fi

        case "${GOOGLECHAT_DB_TYPE,,}" in
            postgres* )
                sanity_var GOOGLECHAT_DB_USER "DB Username for Google Chat"
                sanity_var GOOGLECHAT_DB_PASS "DB Password for Google Chat"
                sanity_var GOOGLECHAT_DB_HOST "DB Host for Google Chat"
                sanity_var GOOGLECHAT_DB_NAME "DB Name for Google Chat"
                counter=0
                export PGPASSWORD=${GOOGLECHAT_DB_PASS}
                until pg_isready --dbname="${GOOGLECHAT_DB_NAME}" --host="${GOOGLECHAT_DB_HOST}" --port="${GOOGLECHAT_DB_PORT}" --username="${GOOGLECHAT_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${GOOGLECHAT_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export GOOGLECHAT_DB_STRING=${GOOGLECHAT_DB_STRING:-"postgres://${GOOGLECHAT_DB_USER}:${GOOGLECHAT_DB_PASS}@${GOOGLECHAT_DB_HOST}:${GOOGLECHAT_DB_PORT}/${GOOGLECHAT_DB_NAME}"}
            set +x
            ;;
            sqlite* )
                if [ ! -d "${GOOGLECHAT_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${GOOGLECHAT_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${GOOGLECHAT_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${GOOGLECHAT_DB_SQLITE_PATH}" ; fi

                export GOOGLECHAT_DB_STRING=${GOOGLECHAT_DB_STRING:-"sqlite://${GOOGLECHAT_DB_SQLITE_PATH}/${GOOGLECHAT_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/googlechat/example.config.yaml "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(GOOGLECHAT_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(GOOGLECHAT_HOMESERVER_DOMAIN) |
                                        .homeserver.verify_ssl = env(GOOGLECHAT_HOMESERVER_TLS_VERIFY) |
                                        .homeserver.software = env(GOOGLECHAT_HOMESERVER_SOFTWARE) |
                                        .homeserver.http_retry_count = env(GOOGLECHAT_HOMESERVER_HTTP_RETRY_COUNT) |
                                        .homeserver.status_endpoint = env(GOOGLECHAT_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(GOOGLECHAT_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.async_media = env(GOOGLECHAT_HOMESERVER_ENABLE_ASYNC_UPLOADS)
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(GOOGLECHAT_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(GOOGLECHAT_LISTEN_IP) |
                                        .appservice.port = env(GOOGLECHAT_LISTEN_PORT) |
                                        .appservice.max_body_size = env(GOOGLECHAT_MAX_BODY_SIZE) |
                                        .appservice.database = env(GOOGLECHAT_DB_STRING) |
                                        .appservice.database_opts.min_size = env(GOOGLECHAT_DB_MIN_SIZE) |
                                        .appservice.database_opts.max_size = env(GOOGLECHAT_DB_MAX_SIZE) |
                                        .appservice.id = env(GOOGLECHAT_APPSERVICE_ID) |
                                        .appservice.bot_username = env(GOOGLECHAT_BOT_USERNAME) |
                                        .appservice.bot_displayname = env(GOOGLECHAT_BOT_DISPLAYNAME) |
                                        .appservice.bot_avatar = env(GOOGLECHAT_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(GOOGLECHAT_ENABLE_EPHEMERAL_EVENTS)
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        if [ -f "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}" && [ -z "${GOOGLECHAT_AS_TOKEN}" ] ; then
            print_debug "[configure_googlechat] Setting as_token in configuration from previously generated registration file"
            export TOI_GOOGLECHAT_AS_TOKEN=$(yq '.as_token' "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_GOOGLECHAT_AS_TOKEN)
                                        ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
            fbastokenskip=true
        elif [ -n "${GOOGLECHAT_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"; then
            print_notice "You've supplied 'GOOGLECHAT_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${GOOGLECHAT_AS_TOKEN}" ] ; then
            print_debug "[configure_googlechat] Updating GOOGLECHAT_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(GOOGLECHAT_AS_TOKEN)
                                        ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        fi

        if [ -f "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}" && [ -z "${GOOGLECHAT_HS_TOKEN}" ] ; then
            print_debug "[configure_googlechat] Setting hs_token in configuration from previously generated registration file"
            export TOI_GOOGLECHAT_HS_TOKEN=$(yq '.hs_token' "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_GOOGLECHAT_HS_TOKEN)
                                        ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
            googlechathstokenskip=true
        elif [ -n "${GOOGLECHAT_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"; then
            print_notice "You've supplied 'GOOGLECHAT_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${GOOGLECHAT_HS_TOKEN}" ] ; then
            print_debug "[configure_googlechat] Updating GOOGLECHAT_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(GOOGLECHAT_HS_TOKEN)
                                        ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .hangouts.device_name = env(GOOGLECHAT_HANGOUTS_DEVICE_NAME)
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(GOOGLECHAT_ENABLE_METRICS) |
                                        .metrics.listen_port = env(GOOGLECHAT_METRICS_LISTEN_PORT)
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .manhole.enabled = env(GOOGLECHAT_ENABLE_MANHOLE) |
                                        .manhole.path = env(GOOGLECHAT_MANHOLE_SOCKET) |
                                        .manhole.whitelist = [ "'$(echo ${GOOGLECHAT_MANHOLE_WHITELIST//,/\",\"})'" ]
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        if var_true "${GOOGLECHAT_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(GOOGLECHAT_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(GOOGLECHAT_TEMPLATE_DISPLAYNAME) |
                                            .bridge.command_prefix = "'$(echo ${GOOGLECHAT_COMMAND_PREFIX})'" |
                                            .bridge.inital_chat_sync = env(GOOGLECHAT_INITIAL_CHAT_SYNC) |
                                            .bridge.invite_own_puppet_to_pm = env(GOOGLECHAT_INVITE_OWN_PUPPET_TO_PM) |
                                            .bridge.sync_with_custom_puppets = env(GOOGLECHAT_SYNC_WITH_CUSTOM_PUPPETS) |
                                            .bridge.sync_direct_chat_list = env(GOOGLECHAT_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.update_avatar_initial_sync = env(GOOGLECHAT_SYNC_UPDATE_AVATAR) |
                                            .bridge.encryption.allow = env(GOOGLECHAT_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(GOOGLECHAT_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(GOOGLECHAT_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(GOOGLECHAT_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(GOOGLECHAT_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(GOOGLECHAT_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(GOOGLECHAT_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(GOOGLECHAT_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(GOOGLECHAT_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(GOOGLECHAT_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(GOOGLECHAT_ENCRYPTION_ROTATION_MESSAGES) |
                                            .bridge.delivery_receipts = env(GOOGLECHAT_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.delivery_error_reports = env(GOOGLECHAT_ENABLE_DELIVERY_ERROR_REPORTS) |
                                            .bridge.message_status_events = env(GOOGLECHAT_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.federate_rooms = env(GOOGLECHAT_FEDERATE_ROOMS) |
                                            .bridge.backfill.enable = env(GOOGLECHAT_BACKFILL_ENABLE) |
                                            .bridge.backfill.invite_own_puppet = env(GOOGLECHAT_BACKFILL_INVITE_OWN_PUPPET) |
                                            .bridge.backfill.initial_thread_limit = env(GOOGLECHAT_BACKFILL_INITIAL_THREAD_LIMIT) |
                                            .bridge.backfill.initial_thread_reply_limit = env(GOOGLECHAT_BACKFILL_INITIAL_THREAD_REPLY_LIMIT) |
                                            .bridge.backfill.initial_nonthread_limit = env(GOOGLECHAT_BACKFILL_INITIAL_NONTHREAD_LIMIT) |
                                            .bridge.backfill.missed_event_limit = env(GOOGLECHAT_BACKFILL_BACKFILL_MISSED_EVENT_LIMIT) |
                                            .bridge.backfill.missed_event_page_size = env(GOOGLECHAT_BACKFILL_BACKFILL_MISSED_EVENT_PAGE_SIZE) |
                                            .bridge.backfill.disable_notifications = env(GOOGLECHAT_BACKFILL_DISABLE_NOTIFICATIONS) |
                                            .bridge.disable_bridge_notices = env(GOOGLECHAT_DISABLE_BRIDGE_NOTICES) |
                                            .bridge.resend_bridge_info = env(GOOGLECHAT_RESEND_BRIDGE_INFO) |
                                            .bridge.unimportant_bridge_notices = env(GOOGLECHAT_UNIMPORTANT_BRIDGE_NOTICES)
                                            .bridge.provisioning.enabled = env(GOOGLECHAT_PROVISIONING_ENABLE) |
                                            .bridge.provisioning.prefix = env(GOOGLECHAT_PROVISIONING_PREFIX) |
                                            .bridge.provisioning.segment_key = env(GOOGLECHAT_PROVISIONING_SEGMENT_KEY) |
                                        ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        set -f

        if [ -n "${GOOGLECHAT_PERMISSIONS_RELAY}" ] ; then
            gcrelays=$(echo "${GOOGLECHAT_PERMISSIONS_RELAY}" | tr "," "\n")
            for gcrelay in $gcrelays; do
                if [ "$gcrelay" = "*" ] ; then
                    export GCRELAY="PLACEHOLDERASTERISK"
                else
                    export GCRELAY=$gcrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${GCRELAY})'" ]+= "relay"
                                            ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
            done
        fi

        if [ -n "${GOOGLECHAT_PERMISSIONS_ADMIN}" ] ; then
            gcadmins=$(echo "${GOOGLECHAT_PERMISSIONS_ADMIN}" | tr "," "\n")
            for gcadmin in $gcadmins; do
                if [ "$gcadmin" = "*" ] ; then
                    export GCADMIN="PLACEHOLDERASTERISK"
                else
                    export GCADMIN=$gcadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${GCADMIN})'" ] += "admin"
                                            ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
            done
        fi

        if [ -n "${GOOGLECHAT_PERMISSIONS_USER}" ] ; then
            gcusers=$(echo "${GOOGLECHAT_PERMISSIONS_USER}" | tr "," "\n")
            for gcuser in $gcusers; do
                if [ "$gcuser" = "*" ] ; then
                    export GCUSER="PLACEHOLDERASTERISK"
                else
                    export GCUSER=$gcuser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(GCUSER)] += "user"
                                            ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"
        fi

        case "${GOOGLECHAT_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_googlechat "${GOOGLECHAT_LOG_PATH}"/"${GOOGLECHAT_LOG_FILE}" bridge_ matrix matrixgooglechat
                export GOOGLECHAT_LOG_TYPE="console,file"
            ;;
            "console" )
                export GOOGLECHAT_LOG_TYPE="console"
            ;;
            "file" )
                create_logrotate bridge_googlechat "${GOOGLECHAT_LOG_PATH}"/"${GOOGLECHAT_LOG_FILE}" bridge_ matrix matrixgooglechat
                export GOOGLECHAT_LOG_TYPE="file"
            ;;
        esac

        s6-setuidgid matrix yq -i   '
                                        .logging.version = 1 |
                                        .logging.handlers.file.class = "logging.FileHandler" |
                                        .logging.handlers.file.filename = "'$(echo "${GOOGLECHAT_LOG_PATH}/${GOOGLECHAT_LOG_FILE}")'" |
                                        del(.logging.handlers.file.backupCount) |
                                        del(.logging.handlers.file.maxBytes) |
                                        .logging.loggers.mau.level = env(GOOGLECHAT_LOG_LEVEL_MAU) |
                                        .logging.loggers.maugclib.level = env(GOOGLECHAT_LOG_LEVEL_MAUGCLIB) |
                                        .logging.loggers.aiohttp.level = env(GOOGLECHAT_LOG_LEVEL_AIOHTTP) |
                                        .logging.root.level = env(GOOGLECHAT_LOG_LEVEL) |
                                        .logging.root.handlers = [ "'$(echo "${GOOGLECHAT_LOG_TYPE,,//,/\",\"}")'" ]
                                    ' "${GOOGLECHAT_CONFIG_PATH}"/"${GOOGLECHAT_CONFIG_FILE}"

        if [ ! -f "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_googlechat] Didn't find a registration file. Generating to '${GOOGLECHAT_REGISTRATION_PATH}/${GOOGLECHAT_REGISTRATION_FILE}'"
            gc_generate_registration=true
        elif var_true "${GOOGLECHAT_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_googlechat] Regenerating registration file to '${GOOGLECHAT_REGISTRATION_PATH}/${GOOGLECHAT_REGISTRATION_FILE}'"
            gc_generate_registration=true
        elif var_true "${fb_force_registration}" ; then
            print_notice "[configure_googlechat] Something has changed  - Force generating registration file to '${GOOGLECHAT_REGISTRATION_PATH}/${GOOGLECHAT_REGISTRATION_FILE}'"
            gc_generate_registration=true
        fi

        if var_true "${gc_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${GOOGLECHAT_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_googlechat \
                                                        -g \
                                                        -c "${GOOGLECHAT_CONFIG_PATH}"/${GOOGLECHAT_CONFIG_FILE} \
                                                        -r "${GOOGLECHAT_REGISTRATION_PATH}"/"${GOOGLECHAT_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_googlechat] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_hookshot() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
            source /assets/defaults/bridge_hookshot
        set +a
    fi


    case "${HOOKSHOT_LOG_FORMAT}" in
        file )
            export HOOKSHOT_LOG_CONSOLE_COLORIZE=false
        ;;
    esac

    case "${HOOKSHOT_LOG_FORMAT}" in
        normal | standard | default )
            export HOOKSHOT_LOG_FORMAT=false
        ;;
        json | structured )
            export HOOKSHOT_LOG_FORMAT=true
        ;;
    esac


    s6-setuidgid matrix yq -i   '
                                    .bridge.domain = env(HOOKSHOT_HOMESERVER_DOMAIN) |
                                    .bridge.url = env(HOOKSHOT_HOMESERVER_ADDRESS) |
                                    .bridge.mediaUrl = env(HOOKSHOT_) |
                                    .bridge.port = env(HOOKSHOT_LISTEN_PORT) |
                                    .bridge.bindAddress = env(HOOKSHOT_LISTEN_IP) |
                                    .passFile = env(HOOKSHOT_PASS_FILE) |
                                    .bot.displayname = env(HOOKSHOT_BOT_DISPLAYNAME) |
                                    .bot.avatar = env(HOOKSHOT_BOT_AVATAR) |
                                    .metrics.enabled = env(HOOKSHOT_ENABLE_METRICS) |
                                    .logging.level = env(HOOKSHOT_LOG_LEVEL) |
                                    .logging.colorize = env(HOOKSHOT_LOG_CONSOLE_COLORIZE) |
                                    .logging.json = env(HOOKSHOT_LOG_FORMAT) |
                                    .logging.timestampFormat = env(HOOKSHOT_LOG_TIMESTAMP_FORMAT)
                                ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"


    if var_true "${HOOKSHOT_ENABLE_PROVISIONING}" ; then
        s6-setuidgid matrix yq -i   '
                                        .provisioning.secret = env(HOOKSHOT_PROVISIONING_SECRET)
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .provisioning
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${HOOKSHOT_ENABLE_QUEUE}" ; then
        sanity_var HOOKSHOT_REDIS_HOST "Redis host for Hookshot"
        s6-setuidgid matrix yq -i   '
                                        .queue.monolithic = env(HOOKSHOT_QUEUE_MONOLITHIC) |
                                        .queue.port = env(HOOKSHOT_REDIS_PORT) |
                                        .queue.host = env(HOOKSHOT_REDIS_HOST)
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .queue
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi


    if var_true "${HOOKSHOT_ENABLE_WIDGETS}" ; then
        s6-setuidgid matrix yq -i   '
                                        .widgets.addToAdminRooms = env(HOOKSHOT_WIDGETS_ADD_TO_ADMIN_ROOMS) |
                                        .widgets.disallowedIpRanges = [ "'$(echo "${HOOKSHOT_WIDGETS_DISALLOWED_IP_RANGLES,,//,/\",\"}")'" ] |
                                        .widgets.roomSetupWidget.addOnInvite = env(HOOKSHOT_WIDGETS_ROOM_SETUP_ADDON_INVITE) |
                                        .widgets.publicUrl = env(HOOKSHOT_WIDGETS_PUBLIC_URL) |
                                        .widgets.branding.widgetTitle = env(HOOKSHOT_WIDGETS_BRANDING_TITLE) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .widgets
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_FEEDS}" ; then
        s6-setuidgid matrix yq -i   '
                                        .feeds.enabled = env(HOOKSHOT_ENABLE_FEEDS) |
                                        .feeds.pollIntervalSeconds = env(FEEDS_POLL_INTERVAL) |
                                        .feeds.pollTimeoutSeconds = env(FEEDS_POLL_TIMEOUT) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .feeds
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_FIGMA}" ; then
        s6-setuidgid matrix yq -i   '
                                        .figma.publicUrl = env(FIGMA_PUBLIC_URL) |
                                        .figma.instances.your-instance.teamId = env(FIGMA_) |
                                        .figma.instances.your-instance.accessToken = env(FIGMA_) |
                                        .figma.instances.your-instance.passcode = env(FIGMA_) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .figma
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_GITHUB}" ; then
        s6-setuidgid matrix yq -i   '
                                        .github.auth.id = env(GITHUB_AUTH_ID) |
                                        .github.auth.privateKeyFile = env(GITHUB_AUTH_PRIVATE_KEY_FILE) |
                                        .github.webhook.secret = env(GITHUB_WEBHOOK_SECRET) |
                                        .github.oauth.client_id = env(GITHUB_OAUTH_CLIENT_ID) |
                                        .github.oauth.client_secret = env(GITHUB_OAUTH_CLIENT_SECRET) |
                                        .github.oauth.redirect_uri = env(GITHUB_OAUTH_REDIRECT_URI) |
                                        .github.defaultOptions.showIssueRoomLink = env(GITHUB_DEFAULT_SHOW_ISSUE_ROOM_LINK) |
                                        .github.defaultOptions.hotlinkIssues = env(GITHUB_DEFAULT_HOTLINK_ISSUES) |
                                        .github.userIdPrefix = env(GITHUB_USER_ID_PREFIX) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"

    else
        s6-setuidgid matrix yq -i   '
                                        del .github
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_GITLAB}" ; then
        s6-setuidgid matrix yq -i   '
                                        .gitlab.instances.gitlab.com = env(HOOKSHOT_) |
                                        .gitlab.instances.gitlab.com.url = env(HOOKSHOT_) |
                                        .gitlab.webhook.secret = env(GITLAB_WEBHOOK_SECRET) |
                                        .gitlab.webhook.publicUrl = env(GITLAB_WEBHOOK_PUBLIC_URL) |
                                        .gitlab.userIdPrefix = env(GITLAB_USER_ID_PREFIX) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .gitlab
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_JIRA}" ; then
        s6-setuidgid matrix yq -i   '
                                        .jira.webhook.secret = env(JIRA_WEBHOOK_SECRET) |
                                        .jira.oauth.client_id = env(JIRA_OAUTH_CLIENT_ID) |
                                        .jira.oauth.client_secret = env(JIRA_OAUTH_CLIENT_SECRET) |
                                        .jira.oauth.redirect_uri = env(JIRA_OAUTH_REDIRECT_URI) |
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                del .jira
                            ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi

    if var_true "${ENABLE_WEBHOOKS}" ; then
        s6-setuidgid matrix yq -i   '
                                        .generic.enabled = env(HOOKSHOT_ENABLE_GENERIC) |
                                        .generic.enableHttpGet = env(WEBHOOK_ENABLE_HTTP_GET) |
                                        .generic.urlPrefix = env(WEBHOOK_URL_PREFIX) |
                                        .generic.userIdPrefix = env(WEBHOOK_USER_ID_PREFIX) |
                                        .generic.allowJsTransformationFunctions = env(WEBHOOK_ALLOW_JS_TRANSFORMATION) |
                                        .generic.waitForComplete = env(WEBHOOK_WAIT_FOR_COMPLETE)
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    else
        s6-setuidgid matrix yq -i   '
                                        del .generic
                                    ' "${HOOKSHOT_CONFIG_PATH}"/"${HOOKSHOT_CONFIG_FILE}"
    fi


#
## This is an example configuration file
#
#bridge:
#  # Basic homeserver configuration
#  #
#  domain: example.com
#  url: http://localhost:8008
#  mediaUrl: http://example.com
#  port: 9993
#  bindAddress: 127.0.0.1
#github:
#  # (Optional) Configure this to enable GitHub support
#  #
#  auth:
#    # Authentication for the GitHub App.
#    #
#    id: 123
#    privateKeyFile: github-key.pem
#  webhook:
#    # Webhook settings for the GitHub app.
#    #
#    secret: secrettoken
#  oauth:
#    # (Optional) Settings for allowing users to sign in via OAuth.
#    #
#    client_id: foo
#    client_secret: bar
#    redirect_uri: https://example.com/bridge_oauth/
#  defaultOptions:
#    # (Optional) Default options for GitHub connections.
#    #
#    showIssueRoomLink: false
#    hotlinkIssues:
#      prefix: "#"
#  userIdPrefix:
#    # (Optional) Prefix used when creating ghost users for GitHub accounts.
#    #
#    _github_
#gitlab:
#  # (Optional) Configure this to enable GitLab support
#  #
#  instances:
#    gitlab.com:
#      url: https://gitlab.com
#  webhook:
#    secret: secrettoken
#    publicUrl: https://example.com/hookshot/
#  userIdPrefix:
#    # (Optional) Prefix used when creating ghost users for GitLab accounts.
#    #
#    _gitlab_
#figma:
#  # (Optional) Configure this to enable Figma support
#  #
#  publicUrl: https://example.com/hookshot/
#  instances:
#    your-instance:
#      teamId: your-team-id
#      accessToken: your-personal-access-token
#      passcode: your-webhook-passcode
#jira:
#  # (Optional) Configure this to enable Jira support. Only specify `url` if you are using a On Premise install (i.e. not atlassian.com)
#  #
#  webhook:
#    # Webhook settings for JIRA
#    #
#    secret: secrettoken
#  oauth:
#    # (Optional) OAuth settings for connecting users to JIRA. See documentation for more information
#    #
#    client_id: foo
#    client_secret: bar
#    redirect_uri: https://example.com/bridge_oauth/
#generic:
#  # (Optional) Support for generic webhook events.
#  #'allowJsTransformationFunctions' will allow users to write short transformation snippets in code, and thus is unsafe in untrusted environments
#  #
#  #
#  enabled: false
#  enableHttpGet: false
#  urlPrefix: https://example.com/webhook/
#  userIdPrefix: _webhooks_
#  allowJsTransformationFunctions: false
#  waitForComplete: false
#feeds:
#  # (Optional) Configure this to enable RSS/Atom feed support
#  #
#  enabled: false
#  pollIntervalSeconds: 600
#  pollTimeoutSeconds: 30
#provisioning:
#  # (Optional) Provisioning API for integration managers
#  #
#  secret: "!secretToken"
#passFile:
#  # A passkey used to encrypt tokens stored inside the bridge.
#  # Run openssl genpkey -out passkey.pem -outform PEM -algorithm RSA -pkeyopt rsa_keygen_bits:4096 to generate
#  #
#  passkey.pem
#bot:
#  # (Optional) Define profile information for the bot user
#  #
#  displayname: GitHub Bot
#  avatar: mxc://half-shot.uk/2876e89ccade4cb615e210c458e2a7a6883fe17d
#metrics:
#  # (Optional) Prometheus metrics support
#  #
#  enabled: true
#queue:
#  # (Optional) Message queue / cache configuration options for large scale deployments.
#  # For encryption to work, must be set to monolithic mode and have a host & port specified.
#  #
#  monolithic: true
#  port: 6379
#  host: localhost
#logging:
#  # (Optional) Logging settings. You can have a severity debug,info,warn,error
#  #
#  level: info
#  colorize: true
#  json: false
#  timestampFormat: HH:mm:ss:SSS
#widgets:
#  # (Optional) EXPERIMENTAL support for complimentary widgets
#  #
#  addToAdminRooms: false
#  disallowedIpRanges:
#    - 127.0.0.0/8
#    - 10.0.0.0/8
#    - 172.16.0.0/12
#    - 192.168.0.0/16
#    - 100.64.0.0/10
#    - 192.0.0.0/24
#    - 169.254.0.0/16
#    - 192.88.99.0/24
#    - 198.18.0.0/15
#    - 192.0.2.0/24
#    - 198.51.100.0/24
#    - 203.0.113.0/24
#    - 224.0.0.0/4
#    - ::1/128
#    - fe80::/10
#    - fc00::/7
#    - 2001:db8::/32
#    - ff00::/8
#    - fec0::/10
#  roomSetupWidget:
#    addOnInvite: false
#  publicUrl: http://example.com/widgetapi/v1/static/
#  branding:
#    widgetTitle: Hookshot Configuration
#permissions:
#  # (Optional) Permissions for using the bridge. See docs/setup.md#permissions for help
#  #
#  - actor: example.com
#    services:
#      - service: "*"
#        level: admin
#listeners:
#  # (Optional) HTTP Listener configuration.
#  # Bind resource endpoints to ports and addresses.
#  # 'port' must be specified. Each listener must listen on a unique port.
#  # 'bindAddress' will default to '127.0.0.1' if not specified, which may not be suited to Docker environments.
#  # 'resources' may be any of webhooks, widgets, metrics, provisioning
#  #
#  - port: 9000
#    bindAddress: 0.0.0.0
#    resources:
#      - webhooks
#  - port: 9001
#    bindAddress: 127.0.0.1
#    resources:
#      - metrics
#      - provisioning
#  - port: 9002
#    bindAddress: 0.0.0.0
#    resources:
#      - widgets
#
#
}

configure_instagram() {
        if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_instagram
        set +a
        print_debug "[configure_meta]"

        if [ ! -d "${INSTAGRAM_CONFIG_PATH}" ] ; then
            mkdir -p "${INSTAGRAM_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${INSTAGRAM_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${INSTAGRAM_CONFIG_PATH}" ; fi

        if [ ! -d "${INSTAGRAM_REGISTRATION_PATH}" ] ; then
            mkdir -p "${INSTAGRAM_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${INSTAGRAM_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${INSTAGRAM_REGISTRATION_PATH}" ; fi

        if [ ! -d "${INSTAGRAM_LOG_PATH}" ] ; then
            mkdir -p "${INSTAGRAM_LOG_PATH}"
        fi
        if [ $(stat -c %U "${INSTAGRAM_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${INSTAGRAM_LOG_PATH}" ; fi

        case "${INSTAGRAM_DB_TYPE,,}" in
            postgres* )
                sanity_var INSTAGRAM_DB_USER "DB Username for Instagram"
                sanity_var INSTAGRAM_DB_PASS "DB Password for Instagram"
                sanity_var INSTAGRAM_DB_HOST "DB Host for Instagram"
                sanity_var INSTAGRAM_DB_NAME "DB Name for Instagram"
                counter=0
                export PGPASSWORD=${INSTAGRAM_DB_PASS}
                until pg_isready --dbname="${INSTAGRAM_DB_NAME}" --host="${INSTAGRAM_DB_HOST}" --port="${INSTAGRAM_DB_PORT}" --username="${INSTAGRAM_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${INSTAGRAM_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export INSTAGRAM_DB_TYPE="postgres"
                export INSTAGRAM_DB_STRING=${INSTAGRAM_DB_STRING:-"postgres://${INSTAGRAM_DB_USER}:${INSTAGRAM_DB_PASS}@${INSTAGRAM_DB_HOST}:${INSTAGRAM_DB_PORT}/${INSTAGRAM_DB_NAME}?sslmode=${INSTAGRAM_DB_SSL_MODE,,}"}
            ;;
            sqlite* )
                if [ ! -d "${INSTAGRAM_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${INSTAGRAM_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${INSTAGRAM_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${INSTAGRAM_DB_SQLITE_PATH}" ; fi
                export INSTAGRAM_DB_TYPE="sqlite-fk-wal"
                export INSTAGRAM_DB_STRING=${INSTAGRAM_DB_STRING:-"sqlite://${INSTAGRAM_DB_SQLITE_PATH}/${INSTAGRAM_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/instagram/example.config.yaml "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(INSTAGRAM_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(INSTAGRAM_HOMESERVER_DOMAIN) |
                                        .homeserver.software = env(INSTAGRAM_HOMESERVER_SOFTWARE) |
                                        .homeserver.status_endpoint = env(INSTAGRAM_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.async_media = env(INSTAGRAM_HOMESERVER_ENABLE_ASYNC_UPLOADS) |
                                        .homeserver.ping_interval_seconds = env(INSTAGRAM_HOMESERVER_PING_INTERVAL)
                                    ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(INSTAGRAM_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(INSTAGRAM_LISTEN_IP) |
                                        .appservice.port = env(INSTAGRAM_LISTEN_PORT) |
                                        .appservice.database.type = env(INSTAGRAM_DB_TYPE) |
                                        .appservice.database.uri = env(INSTAGRAM_DB_STRING) |
                                        .appservice.database.max_open_conns = env(INSTAGRAM_DB_MAX_OPEN_CONNECTIONS) |
                                        .appservice.database.max_idle_conns = env(INSTAGRAM_DB_MAX_IDLE_CONNECTIONS) |
                                        .appservice.id = env(INSTAGRAM_APPSERVICE_ID) |
                                        .appservice.bot.username = env(INSTAGRAM_BOT_USERNAME) |
                                        .appservice.bot.displayname = env(INSTAGRAM_BOT_DISPLAYNAME) |
                                        .appservice.bot.avatar = env(INSTAGRAM_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(INSTAGRAM_ENABLE_EPHEMERAL_EVENTS) |
                                        .appservice.async_transactions = env(INSTAGRAM_ENABLE_ASYNC_TRANSACTIONS)
                                    ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"


        if [ -f "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}" && [ -z "${INSTAGRAM_AS_TOKEN}" ] ; then
            print_debug "[configure_instagram] Setting as_token in configuration from previously generated registration file"
            export TOI_INSTAGRAM_AS_TOKEN=$(yq '.as_token' "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_instagram_AS_TOKEN)
                                        ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            fbastokenskip=true
        elif [ -n "${INSTAGRAM_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"; then
            print_notice "You've supplied 'INSTAGRAM_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${INSTAGRAM_AS_TOKEN}" ] ; then
            print_debug "[configure_instagram] Updating INSTAGRAM_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(INSTAGRAM_AS_TOKEN)
                                        ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        fi

        if [ -f "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}" && [ -z "${INSTAGRAM_HS_TOKEN}" ] ; then
            print_debug "[configure_instagram] Setting hs_token in configuration from previously generated registration file"
            export TOI_INSTAGRAM_HS_TOKEN=$(yq '.hs_token' "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_instagram_HS_TOKEN)
                                        ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        elif [ -n "${INSTAGRAM_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"; then
            print_notice "You've supplied 'INSTAGRAM_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${INSTAGRAM_HS_TOKEN}" ] ; then
            print_debug "[configure_instagram] Updating INSTAGRAM_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(INSTAGRAM_HS_TOKEN)
                                        ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(INSTAGRAM_ENABLE_METRICS) |
                                        .metrics.listen = env(INSTAGRAM_METRICS_LISTEN_IP_PORT)
                                    ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .meta.mode = "instagram" |
                                        .meta.ig_e2ee = false
                                    ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"

        if var_true "${INSTAGRAM_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(INSTAGRAM_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(INSTAGRAM_TEMPLATE_DISPLAYNAME) |
                                            .bridge.private_chat_portal_meta = env(INSTAGRAM_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.portal_message_buffer = env(INSTAGRAM_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.personal_filtering_spaces = env(INSTAGRAM_PERSONAL_FILTERING_SPACES) |
                                            .bridge.bridge_notices = env(INSTAGRAM_BRIDGE_NOTICES) |
                                            .bridge.delivery_receipts = env(INSTAGRAM_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(INSTAGRAM_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(INSTAGRAM_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.disable_bridge_alerts = env(INSTAGRAM_DISABLE_BRIDGE_NOTICES) |
                                            .bridge.sync_direct_chat_list = env(INSTAGRAM_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.resend_bridge_info = env(INSTAGRAM_RESEND_BRIDGE_INFO) |
                                            .bridge.caption_in_message = env(INSTAGRAM_CAPTION_IN_MESSAGE) |
                                            .bridge.federate_rooms = env(INSTAGRAM_FEDERATE_ROOMS) |
                                            .bridge.mute_bridging = env(INSTAGRAM_MUTE_BRIDGING) |
                                            .bridge.double_puppet_allow_discovery = env(INSTAGRAM_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.command_prefix = "'$(echo ${INSTAGRAM_COMMAND_PREFIX})'" |
                                            .bridge.backfill.enabled = env(INSTAGRAM_BRIDGE_BACKFILL_ENABLED) |
                                            .bridge.backfill.inbox_fetch_pages = env(INSTAGRAM_BRIDGE_BACKFILL_INBOX_FETCH_PAGES) |
                                            .bridge.backfill.history_fetch_pages = env(INSTAGRAM_BRIDGE_BACKFILL_HISTORY_FETCH_PAGES) |
                                            .bridge.backfill.catchup_fetch_pages = env(INSTAGRAM_BRIDGE_BACKFILL_CATCHUP_FETCH_PAGES) |
                                            .bridge.backfill.unread_hours_threshold = env(INSTAGRAM_BRIDGE_BACKFILL_UNREAD_HOURS_THRESHOLD) |
                                            .bridge.backfill.queue.pages_at_once = env(INSTAGRAM_BRIDGE_BACKFILL_QUEUE_PAGES_AT_ONCE) |
                                            .bridge.backfill.queue.max_pages = env(INSTAGRAM_BRIDGE_BACKFILL_QUEUE_MAX_PAGES) |
                                            .bridge.backfill.queue.sleep_between_tasks = env(INSTAGRAM_BRIDGE_BACKFILL_QUEUE_SLEEP_BETWEEN_TASKS) |
                                            .bridge.backfill.queue.dont_fetch_xma = env(INSTAGRAM_BRIDGE_BACKFILL_QUEUE_DONT_FETCH_XMA) |
                                            .bridge.management_room_text.welcome = env(INSTAGRAM_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            .bridge.management_room_text.welcome_connected = env(INSTAGRAM_MANAGEMENT_ROOM_TEXT_WELCOME_CONNECTED) |
                                            .bridge.management_room_text.welcome_unconnected = env(INSTAGRAM_MANAGEMENT_ROOM_TEXT_WELCOME_UNCONNECTED) |
                                            .bridge.management_room_text.additional_help = "'$(echo ${INSTAGRAM_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP})'" |
                                            .bridge.encryption.allow = env(INSTAGRAM_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(INSTAGRAM_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(INSTAGRAM_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(INSTAGRAM_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(INSTAGRAM_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(INSTAGRAM_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(INSTAGRAM_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(INSTAGRAM_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(INSTAGRAM_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(INSTAGRAM_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(INSTAGRAM_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        set -f

        if [ -n "${INSTAGRAM_PERMISSIONS_RELAY}" ] ; then
            instagramrelays=$(echo "${INSTAGRAM_PERMISSIONS_RELAY}" | tr "," "\n")
            for instagramrelay in $instagramrelays; do
                if [ "$instagramrelay" = "*" ] ; then
                    export INSTAGRAMRELAY="PLACEHOLDERASTERISK"
                else
                    export INSTAGRAMRELAY=$instagramrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${INSTAGRAMRELAY})'" ]+= "relay"
                                            ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            done
        fi

        if [ -n "${INSTAGRAM_PERMISSIONS_ADMIN}" ] ; then
            instagramadmins=$(echo "${INSTAGRAM_PERMISSIONS_ADMIN}" | tr "," "\n")
            for instagramadmin in $instagramadmins; do
                if [ "$instagramadmin" = "*" ] ; then
                    export INSTAGRAMADMIN="PLACEHOLDERASTERISK"
                else
                    export INSTAGRAMADMIN=$instagramadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${INSTAGRAMADMIN})'" ] += "admin"
                                            ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            done
        fi

        if [ -n "${INSTAGRAM_PERMISSIONS_USER}" ] ; then
            instagramusers=$(echo "${INSTAGRAM_PERMISSIONS_USER}" | tr "," "\n")
            for instagramuser in $instagramusers; do
                if [ "$instagramuser" = "*" ] ; then
                    export INSTAGRAMUSER="PLACEHOLDERASTERISK"
                else
                    export INSTAGRAMUSER=$instagramuser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(INSTAGRAMUSER)] += "user"
                                            ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        fi
        s6-setuidgid matrix yq -i 'del(.logging)' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        yq -i '.logging.min_level = env(INSTAGRAM_LOG_LEVEL)' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
        case "${INSTAGRAM_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_instagram "${INSTAGRAM_LOG_PATH}"/"${INSTAGRAM_LOG_FILE}" bridge_ matrix matrixinstagram
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            },
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${INSTAGRAM_LOG_PATH}/${INSTAGRAM_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            ;;
            "console" )
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            }
                        ]
                      ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            ;;
            "file" )
                create_logrotate bridge_instagram "${INSTAGRAM_LOG_PATH}"/"${INSTAGRAM_LOG_FILE}" bridge_ matrix matrixinstagram
                yq -i '
                        .logging.writers = [
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${INSTAGRAM_LOG_PATH}/${INSTAGRAM_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${INSTAGRAM_CONFIG_PATH}"/"${INSTAGRAM_CONFIG_FILE}"
            ;;
        esac

        if [ ! -f "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_instagram] Didn't find a registration file. Generating to '${INSTAGRAM_REGISTRATION_PATH}/${INSTAGRAM_REGISTRATION_FILE}'"
            instagram_generate_registration=true
        elif var_true "${INSTAGRAM_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_instagram] Regenerating registration file to '${INSTAGRAM_REGISTRATION_PATH}/${INSTAGRAM_REGISTRATION_FILE}'"
            instagram_generate_registration=true
        elif var_true "${instagram_force_registration}" ; then
            print_notice "[configure_instagram] Something has changed  - Force generating registration file to '${INSTAGRAM_REGISTRATION_PATH}/${INSTAGRAM_REGISTRATION_FILE}'"
            instagram_generate_registration=true
        fi

        if var_true "${instagram_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${INSTAGRAM_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_instagram \
                                                        -g \
                                                        -c "${INSTAGRAM_CONFIG_PATH}"/${INSTAGRAM_CONFIG_FILE} \
                                                        -r "${INSTAGRAM_REGISTRATION_PATH}"/"${INSTAGRAM_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_instagram] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_signal() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_signal
        set +a
        print_debug "[configure_signal]"

        if [ ! -d "${SIGNAL_CONFIG_PATH}" ] ; then
            mkdir -p "${SIGNAL_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${SIGNAL_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${SIGNAL_CONFIG_PATH}" ; fi

        if [ ! -d "${SIGNAL_REGISTRATION_PATH}" ] ; then
            mkdir -p "${SIGNAL_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${SIGNAL_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${SIGNAL_REGISTRATION_PATH}" ; fi

        if [ ! -d "${SIGNAL_LOG_PATH}" ] ; then
            mkdir -p "${SIGNAL_LOG_PATH}"
        fi
        if [ $(stat -c %U "${SIGNAL_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${SIGNAL_LOG_PATH}" ; fi

        case "${SIGNAL_DB_TYPE,,}" in
            postgres* )
                sanity_var SIGNAL_DB_USER "DB Username for Signal"
                sanity_var SIGNAL_DB_PASS "DB Password for Signal"
                sanity_var SIGNAL_DB_HOST "DB Host for Signal"
                sanity_var SIGNAL_DB_NAME "DB Name for Signal"
                counter=0
                export PGPASSWORD=${SIGNAL_DB_PASS}
                until pg_isready --dbname="${SIGNAL_DB_NAME}" --host="${SIGNAL_DB_HOST}" --port="${SIGNAL_DB_PORT}" --username="${SIGNAL_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${SIGNAL_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export SIGNAL_DB_TYPE="postgres"
                export SIGNAL_DB_STRING=${SIGNAL_DB_STRING:-"postgres://${SIGNAL_DB_USER}:${SIGNAL_DB_PASS}@${SIGNAL_DB_HOST}:${SIGNAL_DB_PORT}/${SIGNAL_DB_NAME}?sslmode=${SIGNAL_DB_SSL_MODE,,}"}
            ;;
            sqlite* )
                if [ ! -d "${SIGNAL_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${SIGNAL_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${SIGNAL_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${SIGNAL_DB_SQLITE_PATH}" ; fi
                export SIGNAL_DB_TYPE="sqlite-fk-wal"
                export SIGNAL_DB_STRING=${SIGNAL_DB_STRING:-"sqlite://${SIGNAL_DB_SQLITE_PATH}/${SIGNAL_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/signal/example.config.yaml "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(SIGNAL_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(SIGNAL_HOMESERVER_DOMAIN) |
                                        .homeserver.verify_ssl = env(SIGNAL_HOMESERVER_TLS_VERIFY) |
                                        .homeserver.software = env(SIGNAL_HOMESERVER_SOFTWARE) |
                                        .homeserver.http_retry_count = env(SIGNAL_HOMESERVER_HTTP_RETRY_COUNT) |
                                        .homeserver.status_endpoint = env(SIGNAL_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(SIGNAL_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.connection_limit = env(SIGNAL_HOMESERVER_CONNECTION_LIMIT) |
                                        .homeserver.async_media = env(SIGNAL_HOMESERVER_ENABLE_ASYNC_UPLOADS) |
                                        .homeserver.ping_interval_seconds = env(SIGNAL_HOMESERVER_PING_INTERVAL)
                                    ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(SIGNAL_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(SIGNAL_LISTEN_IP) |
                                        .appservice.port = env(SIGNAL_LISTEN_PORT) |
                                        .appservice.database.type = env(SIGNAL_DB_TYPE) |
                                        .appservice.database.uri = env(SIGNAL_DB_STRING) |
                                        .appservice.database.max_open_conns = env(SIGNAL_DB_MAX_OPEN_CONNECTIONS) |
                                        .appservice.database.max_idle_conns = env(SIGNAL_DB_MAX_IDLE_CONNECTIONS) |
                                        .appservice.id = env(SIGNAL_APPSERVICE_ID) |
                                        .appservice.bot.username = env(SIGNAL_BOT_USERNAME) |
                                        .appservice.bot.displayname = env(SIGNAL_BOT_DISPLAYNAME) |
                                        .appservice.bot.avatar = env(SIGNAL_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(SIGNAL_ENABLE_EPHEMERAL_EVENTS)
                                    ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"


        if [ -f "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}" && [ -z "${SIGNAL_AS_TOKEN}" ] ; then
            print_debug "[configure_signal] Setting as_token in configuration from previously generated registration file"
            export TOI_SIGNAL_AS_TOKEN=$(yq '.as_token' "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_SIGNAL_AS_TOKEN)
                                        ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            fbastokenskip=true
        elif [ -n "${SIGNAL_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"; then
            print_notice "You've supplied 'SIGNAL_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${SIGNAL_AS_TOKEN}" ] ; then
            print_debug "[configure_signal] Updating SIGNAL_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(SIGNAL_AS_TOKEN)
                                        ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        fi

        if [ -f "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}" && [ -z "${SIGNAL_HS_TOKEN}" ] ; then
            print_debug "[configure_signal] Setting hs_token in configuration from previously generated registration file"
            export TOI_SIGNAL_HS_TOKEN=$(yq '.hs_token' "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_SIGNAL_HS_TOKEN)
                                        ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        elif [ -n "${SIGNAL_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"; then
            print_notice "You've supplied 'SIGNAL_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${SIGNAL_HS_TOKEN}" ] ; then
            print_debug "[configure_signal] Updating SIGNAL_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(SIGNAL_HS_TOKEN)
                                        ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(SIGNAL_ENABLE_METRICS) |
                                        .metrics.listen = env(SIGNAL_METRICS_LISTEN_IP_PORT)
                                    ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"

        if var_true "${SIGNAL_CONFIGURE_BRIDGE}" ; then
            # TODO
            # .bridge.message_handling_timeout
            # .bridge.login_shared_secret_map + double_puppet
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(SIGNAL_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(SIGNAL_TEMPLATE_DISPLAYNAME) |
                                            .bridge.private_chat_portal_meta = env(SIGNAL_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.use_contact_avatars = env(SIGNAL_USE_CONTACT_AVATARS) |
                                            .bridge.number_in_topic = env(SIGNAL_INCLUDE_NUMBER_IN_TOPIC) |
                                            .bridge.note_to_self_avatar = env(SIGNAL_NOTE_TO_SELF_AVATAR) |
                                            .bridge.portal_message_buffer = env(SIGNAL_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.personal_filtering_spaces = env(SIGNAL_PERSONAL_FILTERING_SPACES) |
                                            .bridge.bridge_notices = env(SIGNAL_BRIDGE_NOTICES) |
                                            .bridge.delivery_receipts = env(SIGNAL_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(SIGNAL_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(SIGNAL_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.sync_direct_chat_list = env(SIGNAL_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.resend_bridge_info = env(SIGNAL_RESEND_BRIDGE_INFO) |
                                            .bridge.public_portals = env(SIGNAL_PUBLIC_PORTALS) |
                                            .bridge.caption_in_message = env(SIGNAL_CAPTION_IN_MESSAGE) |
                                            .bridge.federate_rooms = env(SIGNAL_FEDERATE_ROOMS) |
                                            .bridge.double_puppet_allow_discovery = env(SIGNAL_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.command_prefix = "'$(echo ${SIGNAL_COMMAND_PREFIX})'" |
                                            .bridge.management_room_text.welcome = env(SIGNAL_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            .bridge.management_room_text.welcome_connected = env(SIGNAL_MANAGEMENT_ROOM_TEXT_WELCOME_CONNECTED) |
                                            .bridge.management_room_text.welcome_unconnected = env(SIGNAL_MANAGEMENT_ROOM_TEXT_WELCOME_UNCONNECTED) |
                                            .bridge.management_room_text.additional_help = "'$(echo ${SIGNAL_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP})'" |
                                            .bridge.encryption.allow = env(SIGNAL_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(SIGNAL_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(SIGNAL_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(SIGNAL_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(SIGNAL_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(SIGNAL_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(SIGNAL_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(SIGNAL_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(SIGNAL_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(SIGNAL_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(SIGNAL_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        set -f

        if [ -n "${SIGNAL_PERMISSIONS_RELAY}" ] ; then
            signalrelays=$(echo "${SIGNAL_PERMISSIONS_RELAY}" | tr "," "\n")
            for signalrelay in $signalrelays; do
                if [ "$signalrelay" = "*" ] ; then
                    export SIGNALRELAY="PLACEHOLDERASTERISK"
                else
                    export SIGNALRELAY=$signalrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${SIGNALRELAY})'" ]+= "relay"
                                            ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            done
        fi

        if [ -n "${SIGNAL_PERMISSIONS_ADMIN}" ] ; then
            signaladmins=$(echo "${SIGNAL_PERMISSIONS_ADMIN}" | tr "," "\n")
            for signaladmin in $signaladmins; do
                if [ "$signaladmin" = "*" ] ; then
                    export SIGNALADMIN="PLACEHOLDERASTERISK"
                else
                    export SIGNALADMIN=$signaladmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${SIGNALADMIN})'" ] += "admin"
                                            ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            done
        fi

        if [ -n "${SIGNAL_PERMISSIONS_USER}" ] ; then
            signalusers=$(echo "${SIGNAL_PERMISSIONS_USER}" | tr "," "\n")
            for signaluser in $signalusers; do
                if [ "$signaluser" = "*" ] ; then
                    export SIGNALUSER="PLACEHOLDERASTERISK"
                else
                    export SIGNALUSER=$signaluser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(SIGNALUSER)] += "user"
                                            ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.logging)' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        yq -i '.logging.min_level = env(SIGNAL_LOG_LEVEL)' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
        case "${SIGNAL_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_signal "${SIGNAL_LOG_PATH}"/"${SIGNAL_LOG_FILE}" bridge_ matrix matrixsignal
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            },
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${SIGNAL_LOG_PATH}/${SIGNAL_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            ;;
            "console" )
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            }
                        ]
                      ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            ;;
            "file" )
                create_logrotate bridge_signal "${SIGNAL_LOG_PATH}"/"${SIGNAL_LOG_FILE}" bridge_ matrix matrixsignal
                yq -i '
                        .logging.writers = [
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${SIGNAL_LOG_PATH}/${SIGNAL_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${SIGNAL_CONFIG_PATH}"/"${SIGNAL_CONFIG_FILE}"
            ;;
        esac

        if [ ! -f "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_signal] Didn't find a registration file. Generating to '${SIGNAL_REGISTRATION_PATH}/${SIGNAL_REGISTRATION_FILE}'"
            signal_generate_registration=true
        elif var_true "${SIGNAL_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_signal] Regenerating registration file to '${SIGNAL_REGISTRATION_PATH}/${SIGNAL_REGISTRATION_FILE}'"
            signal_generate_registration=true
        elif var_true "${signal_force_registration}" ; then
            print_notice "[configure_signal] Something has changed  - Force generating registration file to '${SIGNAL_REGISTRATION_PATH}/${SIGNAL_REGISTRATION_FILE}'"
            signal_generate_registration=true
        fi

        if var_true "${signal_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${SIGNAL_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_signal \
                                                        -g \
                                                        -c "${SIGNAL_CONFIG_PATH}"/${SIGNAL_CONFIG_FILE} \
                                                        -r "${SIGNAL_REGISTRATION_PATH}"/"${SIGNAL_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_signal] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_slack() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_slack
        set +a
        print_debug "[configure_slack]"

        if [ ! -d "${SLACK_CONFIG_PATH}" ] ; then
            mkdir -p "${SLACK_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${SLACK_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${SLACK_CONFIG_PATH}" ; fi

        if [ ! -d "${SLACK_REGISTRATION_PATH}" ] ; then
            mkdir -p "${SLACK_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${SLACK_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${SLACK_REGISTRATION_PATH}" ; fi

        if [ ! -d "${SLACK_LOG_PATH}" ] ; then
            mkdir -p "${SLACK_LOG_PATH}"
        fi
        if [ $(stat -c %U "${SLACK_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${SLACK_LOG_PATH}" ; fi

        if [ $(stat -c %U "${DATA_PATH}") != "matrix" ] ; then chown matrix:matrix "${DATA_PATH}" ; fi

        case "${SLACK_DB_TYPE,,}" in
            postgres* )
                sanity_var SLACK_DB_USER "DB Username for Slack"
                sanity_var SLACK_DB_PASS "DB Password for Slack"
                sanity_var SLACK_DB_HOST "DB Host for Slack"
                sanity_var SLACK_DB_NAME "DB Name for Slack"
                counter=0
                export PGPASSWORD=${SLACK_DB_PASS}
                until pg_isready --dbname="${SLACK_DB_NAME}" --host="${SLACK_DB_HOST}" --port="${SLACK_DB_PORT}" --username="${SLACK_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${SLACK_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                if var_true "${SLACK_DB_ENABLE_TLS}" ; then
                    slack_db_tls="?sslmode=enable"
                else
                    slack_db_tls="?sslmode=disable"
                fi
                export SLACK_DB_TYPE=postgres
                export SLACK_DB_STRING=${SLACK_DB_STRING:-"postgres://${SLACK_DB_USER}:${SLACK_DB_PASS}@${SLACK_DB_HOST}:${SLACK_DB_PORT}/${SLACK_DB_NAME}${slack_db_tls}"}
            ;;
            sqlite* )
                if [ ! -d "${SLACK_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${SLACK_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${SLACK_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${SLACK_DB_SQLITE_PATH}" ; fi
                export SLACK_DB_TYPE=sqlite-fk-wal
                export SLACK_DB_STRING=${SLACK_DB_STRING:-"file://${SLACK_DB_SQLITE_PATH}/${SLACK_DB_SQLITE_FILE}?_txlock=immediate"}
            ;;
        esac

        if [ ! -f "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/slack/example.config.yaml "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(SLACK_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(SLACK_HOMESERVER_DOMAIN) |
                                        .homeserver.software = env(SLACK_HOMESERVER_SOFTWARE) |
                                        .homeserver.status_endpoint = env(SLACK_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(SLACK_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.async_media = env(SLACK_HOMESERVER_ENABLE_ASYNC_UPLOADS)
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(SLACK_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(SLACK_LISTEN_IP) |
                                        .appservice.port = env(SLACK_LISTEN_PORT) |
                                        .appservice.database.type = env(SLACK_DB_TYPE) |
                                        .appservice.database.uri = env(SLACK_DB_STRING) |
                                        .appservice.database.max_open_conns = env(SLACK_DB_CONNECTIONS_MAX_OPEN) |
                                        .appservice.database.max_idle_conns = env(SLACK_DB_CONNECTIONS_MAX_IDLE) |
                                        .appservice.database.max_conn_idle_time = env(SLACK_DB_CONNECTIONS_MAX_IDLE_LIFETIME) |
                                        .appservice.database.max_conn_lifetime = env(SLACK_DB_CONNECTIONS_MAX_LIFETIME) |
                                        .appservice.id = env(SLACK_APPSERVICE_ID) |
                                        .appservice.bot_username = env(SLACK_BOT_USERNAME) |
                                        .appservice.bot_displayname = env(SLACK_BOT_DISPLAYNAME) |
                                        .appservice.bot_avatar = env(SLACK_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(SLACK_ENABLE_EPHEMERAL_EVENTS) |
                                        .appservice.async_transactions = env(SLACK_ENABLE_ASYNC_TRANSACTIONS)
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"


        if [ -f "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}" && [ -z "${SLACK_AS_TOKEN}" ] ; then
            print_debug "[configure_slack] Setting as_token in configuration from previously generated registration file"
            export TOI_SLACK_AS_TOKEN=$(yq '.as_token' "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_SLACK_AS_TOKEN)
                                        ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
            slackastokenskip=true
        elif [ -n "${SLACK_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"; then
            print_notice "You've supplied 'SLACK_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${SLACK_AS_TOKEN}" ] ; then
            print_debug "[configure_slack] Updating SLACK_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(SLACK_AS_TOKEN)
                                        ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        fi

        if [ -f "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}" && [ -z "${SLACK_HS_TOKEN}" ] ; then
            print_debug "[configure_slack] Setting hs_token in configuration from previously generated registration file"
            export TOI_SLACK_HS_TOKEN=$(yq '.hs_token' "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_SLACK_HS_TOKEN)
                                        ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
            slackhstokenskip=true
        elif [ -n "${SLACK_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"; then
            print_notice "You've supplied 'SLACK_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${SLACK_HS_TOKEN}" ] ; then
            print_debug "[configure_slack] Updating SLACK_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(SLACK_HS_TOKEN)
                                        ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(SLACK_ENABLE_METRICS) |
                                        .metrics.listen = "'$(echo ${SLACK_METRICS_LISTEN_IP}:${SLACK_METRICS_LISTEN_PORT})'"
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .segment_key = env(SLACK_SEGMENT_API_KEY)
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .slack.os_name = env(SLACK_OS_NAME) |
                                        .slack.browser_name = env(SLACK_BROWSER_NAME)
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"

        if var_true "${SLACK_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(SLACK_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(SLACK_TEMPLATE_DISPLAYNAME) |
                                            .bridge.personal_filtering_spaces = env(SLACK_PERSONAL_FILTERING_SPACES) |
                                            .bridge.delivery_receipts = env(SLACK_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(SLACK_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(SLACK_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.call_start_notices = env(SLACK_ENABLE_CALL_START_NOTICES) |
                                            .bridge.identity_change_notices = env(SLACK_ENABLE_IDENTITY_CHANGE_NOTICES) |
                                            .bridge.portal_message_buffer = env(SLACK_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.federate_rooms = env(SLACK_FEDERATE_ROOMS) |
                                            .bridge.command_prefix = "'$(echo ${SLACK_COMMAND_PREFIX})'" |
                                            .bridge.encryption.allow = env(SLACK_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(SLACK_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(SLACK_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(SLACK_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(SLACK_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(SLACK_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(SLACK_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(SLACK_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(SLACK_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(SLACK_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(SLACK_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        set -f

        if [ -n "${SLACK_PERMISSIONS_RELAY}" ] ; then
            slackrelays=$(echo "${SLACK_PERMISSIONS_RELAY}" | tr "," "\n")
            for slackrelay in $slackrelays; do
                if [ "$slackrelay" = "*" ] ; then
                    export SLACKRELAY="PLACEHOLDERASTERISK"
                else
                    export SLACKRELAY=$warelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${SLACKRELAY})'" ]+= "relay"
                                            ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
            done
        fi

        if [ -n "${SLACK_PERMISSIONS_ADMIN}" ] ; then
            slackadmins=$(echo "${SLACK_PERMISSIONS_ADMIN}" | tr "," "\n")
            for slackadmin in $slackadmins; do
                if [ "$slackadmin" = "*" ] ; then
                    export SLACKADMIN="PLACEHOLDERASTERISK"
                else
                    export SLACKADMIN=$waadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${SLACKADMIN})'" ] += "admin"
                                            ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
            done
        fi

        if [ -n "${SLACK_PERMISSIONS_USER}" ] ; then
            slackusers=$(echo "${SLACK_PERMISSIONS_USER}" | tr "," "\n")
            for slackuser in $slackusers; do
                if [ "$slackuser" = "*" ] ; then
                    export SLACKUSER="PLACEHOLDERASTERISK"
                else
                    export SLACKUSER=$wauser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(SLACKUSER)] += "user"
                                            ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"
        fi

        case "${SLACK_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_slack "${SLACK_LOG_PATH}"/"${SLACK_LOG_FILE}" bridge_ matrix matrixslack
                export SLACK_LOG_TYPE="console,file"
            ;;
            "console" )
                export SLACK_LOG_TYPE="console"
                export SLACK_LOG_FILE="null"
            ;;
            "file" )
                create_logrotate bridge_slack "${SLACK_LOG_PATH}"/"${SLACK_LOG_FILE}" bridge_ matrix matrixslack
                export SLACK_LOG_TYPE="file"
            ;;
        esac

        s6-setuidgid matrix yq -i   '
                                        .logging.directory = "'$(echo "${SLACK_LOG_PATH}")'" |
                                        .logging.file_name_format = env(SLACK_LOG_FILE) |
                                        .logging.print_level = env(SLACK_LOG_LEVEL) |
                                        .logging.root.handlers = [ "'$(echo "${SLACK_LOG_TYPE,,//,/\",\"}")'" ] |
                                        .logging.timestamp_format = "2006-01-02 15:04:05"
                                    ' "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}"

        create_logrotate bridge_slack "${SLACK_LOG_PATH}"/"${SLACK_LOG_FILE}" bridge_ matrix matrixslack

        if [ ! -f "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_slack] Didn't find a registration file. Generating to '${SLACK_REGISTRATION_PATH}/${SLACK_REGISTRATION_FILE}'"
            slack_generate_registration=true
        elif var_true "${SLACK_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_slack] Regenerating registration file to '${SLACK_REGISTRATION_PATH}/${SLACK_REGISTRATION_FILE}'"
            slack_generate_registration=true
        elif var_true "${wa_force_registration}" ; then
            print_notice "[configure_slack] Something has changed  - Force generating registration file to '${SLACK_REGISTRATION_PATH}/${SLACK_REGISTRATION_FILE}'"
            slack_generate_registration=true
        fi

        if var_true "${slack_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${SLACK_REGISTRATION_PATH}"
            silent s6-setuidgid matrix mautrix-slack \
                                                    -g \
                                                    -c "${SLACK_CONFIG_PATH}"/"${SLACK_CONFIG_FILE}" \
                                                    -r "${SLACK_REGISTRATION_PATH}"/"${SLACK_REGISTRATION_FILE}" \
                                                    || exit $?
            print_notice "[configure_slack] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_telegram() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_telegram
        set +a
        print_debug "[configure_telegram]"
        if [ ! -d "${TELEGRAM_CONFIG_PATH}" ] ; then
            mkdir -p "${TELEGRAM_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${TELEGRAM_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${TELEGRAM_CONFIG_PATH}" ; fi

        if [ ! -d "${TELEGRAM_REGISTRATION_PATH}" ] ; then
            mkdir -p "${TELEGRAM_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${TELEGRAM_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${TELEGRAM_REGISTRATION_PATH}" ; fi

        if [ ! -d "${TELEGRAM_LOG_PATH}" ] ; then
            mkdir -p "${TELEGRAM_LOG_PATH}"
        fi
        if [ $(stat -c %U "${TELEGRAM_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${TELEGRAM_LOG_PATH}" ; fi

        case "${TELEGRAM_DB_TYPE,,}" in
            postgres* )
                sanity_var TELEGRAM_DB_USER "DB Username for Telegram"
                sanity_var TELEGRAM_DB_PASS "DB Password for Telegram"
                sanity_var TELEGRAM_DB_HOST "DB Host for Telegram"
                sanity_var TELEGRAM_DB_NAME "DB Name for Telegram"
                counter=0
                export PGPASSWORD=${TELEGRAM_DB_PASS}
                until pg_isready --dbname="${TELEGRAM_DB_NAME}" --host="${TELEGRAM_DB_HOST}" --port="${TELEGRAM_DB_PORT}" --username="${TELEGRAM_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${TELEGRAM_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                export TELEGRAM_DB_STRING=${TELEGRAM_DB_STRING:-"postgres://${TELEGRAM_DB_USER}:${TELEGRAM_DB_PASS}@${TELEGRAM_DB_HOST}:${TELEGRAM_DB_PORT}/${TELEGRAM_DB_NAME}"}
            ;;
            sqlite* )
                if [ ! -d "${TELEGRAM_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${TELEGRAM_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${TELEGRAM_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${TELEGRAM_DB_SQLITE_PATH}" ; fi

                export TELEGRAM_DB_STRING=${TELEGRAM_DB_STRING:-"sqlite://${TELEGRAM_DB_SQLITE_PATH}/${TELEGRAM_DB_SQLITE_FILE}"}
            ;;
        esac

        if [ ! -f "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/telegram/example.config.yaml "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
        fi

        #.homeserver.status_endpoint = env(TELEGRAM_HOMESERVER_STATUS_ENDPOINT) |
        #.homeserver.message_send_checkpoint_endpoint = env(TELEGRAM_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT)
        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(TELEGRAM_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(TELEGRAM_HOMESERVER_DOMAIN) |
                                        .homeserver.verify_ssl = env(TELEGRAM_HOMESERVER_TLS_VERIFY) |
                                        .homeserver.software = env(TELEGRAM_HOMESERVER_SOFTWARE) |
                                        .homeserver.http_retry_count = env(TELEGRAM_HOMESERVER_HTTP_RETRY_COUNT) |


                                        .homeserver.async_media = env(TELEGRAM_HOMESERVER_ENABLE_ASYNC_UPLOADS)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(TELEGRAM_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(TELEGRAM_LISTEN_IP) |
                                        .appservice.port = env(TELEGRAM_LISTEN_PORT) |
                                        .appservice.max_body_size = env(TELEGRAM_MAX_BODY_SIZE) |
                                        .appservice.database = env(TELEGRAM_DB_STRING) |
                                        .appservice.database_opts.min_size = env(TELEGRAM_DB_MIN_SIZE) |
                                        .appservice.database_opts.max_size = env(TELEGRAM_DB_MAX_SIZE) |
                                        .appservice.id = env(TELEGRAM_APPSERVICE_ID) |
                                        .appservice.bot_username = env(TELEGRAM_BOT_USERNAME) |
                                        .appservice.bot_displayname = env(TELEGRAM_BOT_DISPLAYNAME) |
                                        .appservice.bot_avatar = env(TELEGRAM_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(TELEGRAM_ENABLE_EPHEMERAL_EVENTS)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"


        if [ -f "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}" && [ -z "${TELEGRAM_AS_TOKEN}" ] ; then
            print_debug "[configure_telegram] Setting as_token in configuration from previously generated registration file"
            export TOI_TELEGRAM_AS_TOKEN=$(yq '.as_token' "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_TELEGRAM_AS_TOKEN)
                                        ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
            telegramastokenskip=true
        elif [ -n "${TELEGRAM_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"; then
            print_notice "You've supplied 'TELEGRAM_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${TELEGRAM_AS_TOKEN}" ] ; then
            print_debug "[configure_telegram] Updating TELEGRAM_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TELEGRAM_AS_TOKEN)
                                        ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
        fi

        if [ -f "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}" && [ -z "${TELEGRAM_HS_TOKEN}" ] ; then
            print_debug "[configure_telegram] Setting hs_token in configuration from previously generated registration file"
            export TOI_TELEGRAM_HS_TOKEN=$(yq '.hs_token' "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_TELEGRAM_HS_TOKEN)
                                        ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
            telegramhstokenskip=true
        elif [ -n "${TELEGRAM_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"; then
            print_notice "You've supplied 'TELEGRAM_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${TELEGRAM_HS_TOKEN}" ] ; then
            print_debug "[configure_telegram] Updating TELEGRAM_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TELEGRAM_HS_TOKEN)
                                        ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .appservice.public.enabled = env(TELEGRAM_ENABLE_PUBLIC) |
                                        .appservice.public.prefix = env(TELEGRAM_PUBLIC_PREFIX) |
                                        .appservice.public.external = env(TELEGRAM_PUBLIC_EXTERNAL_URL) |
                                        .appservice.public.shared_secret = env(TELEGRAM_PUBLIC_SHARED_SECRET) |
                                        .appservice.public.allow_matrix_login = env(TELEGRAM_ALLOW_MATRIX_LOGIN) |
                                        .appservice.public.segment_key = env(TELEGRAM_SEGMENT_API_KEY)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(TELEGRAM_ENABLE_METRICS) |
                                        .metrics.listen_port = env(TELEGRAM_METRICS_LISTEN_PORT)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .manhole.enabled = env(TELEGRAM_ENABLE_MANHOLE) |
                                        .manhole.path = env(TELEGRAM_MANHOLE_SOCKET) |
                                        .manhole.whitelist = [ "'$(echo ${TELEGRAM_MANHOLE_WHITELIST//,/\",\"})'" ]
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        if var_true "${TELEGRAM_CONFIGURE_BRIDGE}" ; then
            # .bridge.displayname_preference = [ "'$(echo ${TELEGRAM_TEMPLATE_DISPLAYNAME_PREFERENCE//,/\",\"})'" ] |
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = env(TELEGRAM_TEMPLATE_USERNAME) |
                                            .bridge.alias_template = env(TELEGRAM_TEMPLATE_ALIAS) |
                                            .bridge.displayname_max_length = env(TELEGRAM_TEMPLATE_DISPLAYNAME_MAX_LENGTH) |
                                            .bridge.allow_avatar_remove = env(TELEGRAM_ALLOW_AVATAR_REMOVE) |
                                            .bridge.allow_contact_info = env(TELEGRAM_ALLOW_CONTACT_INFO) |
                                            .bridge.max_initial_member_sync = env(TELEGRAM_MAX_INITIAL_MEMBER_SYNC) |
                                            .bridge.max_member_count = env(TELEGRAM_MAX_MEMBER_COUNT) |
                                            .bridge.sync_channel_members = env(TELEGRAM_SYNC_CHANNEL_MEMBERS) |
                                            .bridge.skip_deleted_members = env(TELEGRAM_SKIP_DELETED_MEMBERS) |
                                            .bridge.startup_sync = env(TELEGRAM_STARTUP_SYNC) |
                                            .bridge.sync_update_limit = env(TELEGRAM_SYNC_UPDATE_LIMIT) |
                                            .bridge.sync_create_limit = env(TELEGRAM_SYNC_CREATE_LIMIT) |
                                            .bridge.sync_deferred_create_all = env(TELEGRAM_SYNC_DEFERRED_CREATE_ALL) |
                                            .bridge.sync_direct_chats = env(TELEGRAM_SYNC_DIRECT_CHATS) |
                                            .bridge.max_telegram_delete = env(TELEGRAM_MAX_TELEGRAM_DELETE) |
                                            .bridge.sync_matrix_state = env(TELEGRAM_SYNC_MATRIX_STATE) |
                                            .bridge.allow_matrix_login = env(TELEGRAM_ALLOW_MATRIX_LOGIN) |
                                            .bridge.public_portals = env(TELEGRAM_PUBLIC_PORTALS) |
                                            .bridge.sync_with_custom_puppets = env(TELEGRAM_SYNC_WITH_CUSTOM_PUPPETS) |
                                            .bridge.sync_direct_chat_list = env(TELEGRAM_SYNC_DIRECT_CHAT_LIST) |
                                            .bridge.double_puppet_allow_discovery = env(TELEGRAM_DOUBLE_PUPPET_ALLOW_DISCOVERY) |
                                            .bridge.telegram_link_preview = env(TELEGRAM_LINK_PREVIEW) |
                                            .bridge.invite_link_resolve = env(TELEGRAM_INVITE_LINK_RESOLVE) |
                                            .bridge.caption_in_message = env(TELEGRAM_CAPTION_IN_MESSAGE) |
                                            .bridge.image_as_file_size = env(TELEGRAM_IMAGE_AS_FILE_SIZE) |
                                            .bridge.image_as_file_pixels = env(TELEGRAM_IMAGE_AS_FILE_PIXELS) |
                                            .bridge.parallel_file_transfer = env(TELEGRAM_PARALLEL_FILE_TRANSFER) |
                                            .bridge.federate_rooms = env(TELEGRAM_FEDERATE_ROOMS) |
                                            .bridge.always_custom_emoji_reaction = env(TELEGRAM_ALWAYS_CUSTOM_EMOJI_REACTION) |
                                            .bridge.animated_sticker.target = env(TELEGRAM_ANIMATED_STICKER_TARGET) |
                                            .bridge.animated_sticker.convert_from_webm = env(TELEGRAM_ANIMATED_STICKER_CONVERT_FROM_WEBM) |
                                            .bridge.animated_sticker.args.width = env(TELEGRAM_ANIMATED_STICKER_ARGS_WIDTH) |
                                            .bridge.animated_sticker.args.height = env(TELEGRAM_ANIMATED_STICKER_ARGS_HEIGHT) |
                                            .bridge.animated_emoji.target = env(TELEGRAM_ANIMATED_EMOJI_TARGET) |
                                            .bridge.animated_emoji.args.width = env(TELEGRAM_ANIMATED_EMOJI_ARGS_WIDTH) |
                                            .bridge.animated_emoji.args.height = env(TELEGRAM_ANIMATED_EMOJI_ARGS_HEIGHT) |
                                            .bridge.animated_emoji.args.fps = env(TELEGRAM_ANIMATED_EMOJI_FPS) |
                                            .bridge.encryption.allow = env(TELEGRAM_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(TELEGRAM_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(TELEGRAM_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(TELEGRAM_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(TELEGRAM_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(TELEGRAM_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(TELEGRAM_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(TELEGRAM_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(TELEGRAM_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(TELEGRAM_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(TELEGRAM_ENCRYPTION_ROTATION_MESSAGES) |
                                            .bridge.private_chat_portal_meta = env(TELEGRAM_PRIVATE_CHAT_PORTAL_META) |
                                            .bridge.delivery_receipts = env(TELEGRAM_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.delivery_error_reports = env(TELEGRAM_ENABLE_DELIVERY_ERROR_REPORTS) |
                                            .bridge.message_status_events = env(TELEGRAM_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.resend_bridge_info = env(TELEGRAM_RESEND_BRIDGE_INFO) |
                                            .bridge.mute_bridging = env(TELEGRAM_MUTE_BRIDGING) |
                                            .bridge.pinned_tag = env(TELEGRAM_PINNED_TAG) |
                                            .bridge.archive_tag = env(TELEGRAM_ARCHIVE_TAG) |
                                            .bridge.tag_only_on_create = env(TELEGRAM_TAG_ONLY_ON_CREATE) |
                                            .bridge.bridge_matrix_leave = env(TELEGRAM_BRIDGE_MATRIX_LEAVE) |
                                            .bridge.kick_on_logout = env(TELEGRAM_KICK_ON_LOGOUT) |
                                            .bridge.always_read_joined_telegram_notice = env(TELEGRAM_ALWAYS_READ_JOINED_TELEGRAM_NOTICE) |
                                            .bridge.create_group_on_invite = env(TELEGRAM_CREATE_GROUP_ON_INVITE) |
                                            .bridge.backfill.enable = env(TELEGRAM_BACKFILL_ENABLE) |
                                            .bridge.backfill.msc2716 = env(TELEGRAM_BACKFILL_ENABLE_MSC2716) |
                                            .bridge.backfill.double_puppet_backfill = env(TELEGRAM_BACKFILL_DOUBLE_PUPPET) |
                                            .bridge.backfill.normal_groups = env(TELEGRAM_BACKFILL_NORMAL_GROUPS) |
                                            .bridge.backfill.unread_hours_threshold = env(TELEGRAM_BACKFILL_UNREAD_HOURS_THRESHOLD) |
                                            .bridge.backfill.forward.initial_limit = env(TELEGRAM_BACKFILL_FORWARD_INITIAL_LIMIT) |
                                            .bridge.backfill.forward.sync_limit = env(TELEGRAM_BACKFILL_FORWARD_SYNC_LIMIT) |
                                            .bridge.backfill.incremental.messages_per_batch = env(TELEGRAM_BACKFILL_INCREMENTAL_MESSAGES_PER_BATCH) |
                                            .bridge.backfill.incremental.post_batch_delay = env(TELEGRAM_BACKFILL_INCREMENTAL_POST_BATCH_DELAY) |
                                            .bridge.backfill.incremental.max_batches.user = env(TELEGRAM_BACKFILL_INCREMENTAL_MAX_BATCHES_USER) |
                                            .bridge.backfill.incremental.max_batches.normal_group = env(TELEGRAM_BACKFILL_INCREMENTAL_MAX_BATCHES_NORMAL_GROUP) |
                                            .bridge.backfill.incremental.max_batches.supergroup = env(TELEGRAM_BACKFILL_INCREMENTAL_MAX_BATCHES_SUPERGROUP) |
                                            .bridge.backfill.incremental.max_batches.channel = env(TELEGRAM_BACKFILL_INCREMENTAL_MAX_BATCHES_CHANNEL) |
                                            .bridge.initial_power_level_overrides.user = env(TELEGRAM_BACKFILL_INITIAL_POWER_LEVEL_OVERRIDES_USER) |
                                            .bridge.initial_power_level_overrides.group = env(TELEGRAM_BACKFILL_INITIAL_POWER_LEVEL_OVERRIDES_GROUP) |
                                            .bridge.bot_messages_as_notices = env(TELEGRAM_BOT_MESSAGES_AS_NOTICES) |
                                            .bridge.bridge_notices.default = env(TELEGRAM_BRIDGE_NOTICES_DEFAULT) |
                                            .bridge.bridge_notices.exceptions = env(TELEGRAM_BRIDGE_NOTICES_EXCEPTIONS) |
                                            .bridge.relay_user_distinguishers = env(TELEGRAM_RELAY_USER_DISTINGUISHERS) |
                                            .bridge.state_event_formats.join = env(TELEGRAM_STATE_EVENT_FORMATS_JOIN) |
                                            .bridge.state_event_formats.leave = env(TELEGRAM_STATE_EVENT_FORMATS_LEAVE) |
                                            .bridge.state_event_formats.name_change = env(TELEGRAM_STATE_EVENT_FORMATS_NAME_CHANGE) |
                                            .bridge.filter.mode = env(TELEGRAM_FILTER_MODE) |
                                            .bridge.filter.list = env(TELEGRAM_FILTER_LIST) |
                                            .bridge.command_prefix = "'$(echo ${TELEGRAM_COMMAND_PREFIX})'" |

                                            .bridge.relaybot.privatechat.invite = env(TELEGRAM_RELAYBOT_PRIVATECHAT_INVITE) |
                                            .bridge.relaybot.privatechat.state_changes = env(TELEGRAM_RELAYBOT_PRIVATECHAT_STATE_CHANGES) |
                                            .bridge.relaybot.privatechat.message = env(TELEGRAM_RELAYBOT_PRIVATECHAT_MESSAGE) |
                                            .bridge.group_chat_invite = env(TELEGRAM_GROUP_CHAT_INVITE) |
                                            .bridge.ignore_unbridged_group_chat = env(TELEGRAM_IGNORE_UNBRIDGED_GROUP_CHAT) |
                                            .bridge.authless_portals = env(TELEGRAM_AUTHLESS_PORTALS) |
                                            .bridge.whitelist_group_admins = env(TELEGRAM_WHITELIST_GROUP_ADMINS) |
                                            .bridge.ignore_own_incoming_events = env(TELEGRAM_IGNORE_OWN_INCOMING_EVENTS)
                                        ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
                                            #.bridge.management_room_text.welcome = strenv(TELEGRAM_MANAGEMENT_ROOM_TEXT_WELCOME) |
                                            #.bridge.management_room_text.welcome_connected = strenv(TELEGRAM_MANAGEMENT_ROOM_TEXT_CONNECTED) |
                                            #.bridge.management_room_text.welcome_unconnected = strenv(TELEGRAM_MANAGEMENT_ROOM_TEXT_UNCONNECTED) |
                                            #.bridge.management_room_text.additional_help = strenv(TELEGRAM_MANAGEMENT_ROOM_TEXT_ADDITIONAL_HELP) |
                                            #.bridge.management_room_multiple_messages = env(TELEGRAM_MANAGEMENT_ROOM_MULTIPLE_MESSAGES) |
                                            #.bridge.displayname_template = env(TELEGRAM_TEMPLATE_DISPLAYNAME) |
                                            #.bridge.emote_format = env(TELEGRAM_EMOTE_FORMAT) |
                                            #.bridge.message_formats.m.text = env(TELEGRAM_MESSAGE_FORMATS_M_TEXT) |
                                            #.bridge.message_formats.m.notice = env(TELEGRAM_MESSAGE_FORMATS_M_NOTICE) |
                                            #.bridge.message_formats.m.emote = env(TELEGRAM_MESSAGE_FORMATS_M_EMOTE) |
                                            #.bridge.message_formats.m.file = env(TELEGRAM_MESSAGE_FORMATS_M_FILE) |
                                            #.bridge.message_formats.m.image = env(TELEGRAM_MESSAGE_FORMATS_M_IMAGE) |
                                            #.bridge.message_formats.m.audio = env(TELEGRAM_MESSAGE_FORMATS_M_AUDIO) |
                                            #.bridge.message_formats.m.video = env(TELEGRAM_MESSAGE_FORMATS_M_VIDEO) |
                                            #.bridge.message_formats.m.location = env(TELEGRAM_MESSAGE_FORMATS_M_LOCATION) |
        fi


        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
        set -f

        if [ -n "${TELEGRAM_PERMISSIONS_RELAY}" ] ; then
            telegramrelays=$(echo "${TELEGRAM_PERMISSIONS_RELAY}" | tr "," "\n")
            for telegramrelay in $telegramrelays; do
                if [ "$telegramrelay" = "*" ] ; then
                    export TELEGRAMRELAY="PLACEHOLDERASTERISK"
                else
                    export TELEGRAMRELAY=$telegramrelay
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[  "'$(echo ${TELEGRAMRELAY})'" ]+= "relaybot"
                                            ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
            done
        fi

        if [ -n "${TELEGRAM_PERMISSIONS_ADMIN}" ] ; then
            telegramadmins=$(echo "${TELEGRAM_PERMISSIONS_ADMIN}" | tr "," "\n")
            for telegramadmin in $telegramadmins; do
                if [ "$telegramadmin" = "*" ] ; then
                    export TELEGRAMADMIN="PLACEHOLDERASTERISK"
                else
                    export TELEGRAMADMIN=$telegramadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${TELEGRAMADMIN})'" ] += "admin"
                                            ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
            done
        fi

        if [ -n "${TELEGRAM_PERMISSIONS_USER}" ] ; then
            telegramusers=$(echo "${TELEGRAM_PERMISSIONS_USER}" | tr "," "\n")
            for telegramuser in $telegramusers; do
                if [ "$telegramuser" = "*" ] ; then
                    export TELEGRAMUSER="PLACEHOLDERASTERISK"
                else
                    export TELEGRAMUSER=$telegramuser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(TELEGRAMUSER)] += "user"
                                            ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .telegram.api_id = env(TELEGRAM_API_ID) |
                                        .telegram.api_hash = env(TELEGRAM_API_HASH) |
                                        .telegram.bot_token = env(TELEGRAM_BOT_TOKEN) |
                                        .telegram.catch_up = env(TELEGRAM_CATCH_UP) |
                                        .telegram.sequential_updates = env(TELEGRAM_SEQUENTIAL_UPDATES) |
                                        .telegram.exit_on_update_error = env(TELEGRAM_EXIT_ON_UPDATE_ERROR) |
                                        .telegram.connection.timeout = env(TELEGRAM_CONNECTION_TIMEOUT) |
                                        .telegram.connection.retries = env(TELEGRAM_CONNECTION_RETRIES) |
                                        .telegram.connection.retry_delay = env(TELEGRAM_CONNECTION_RETRY_DELAY) |
                                        .telegram.connection.flood_sleep_threshold = env(TELEGRAM_CONNECTION_FLOOD_SLEEP_THRESHOLD) |
                                        .telegram.connection.request_retries = env(TELEGRAM_CONNECTION_REQUEST_RETRIES) |
                                        .telegram.device_info.device_model = env(TELEGRAM_DEVICE_MODEL) |
                                        .telegram.device_info.system_version = env(TELEGRAM_DEVICE_SYSTEM_VERSION) |
                                        .telegram.device_info.app_version = env(TELEGRAM_DEVICE_APP_VERSION) |
                                        .telegram.device_info.lang_code = env(TELEGRAM_DEVICE_LANG_CODE) |
                                        .telegram.device_info.system_lang_code = env(TELEGRAM_DEVICE_SYSTEM_LANG_CODE) |
                                        .telegram.server.enabled = env(TELEGRAM_SERVER_ENABLED) |
                                        .telegram.server.dc = env(TELEGRAM_SERVER_DC) |
                                        .telegram.server.ip = env(TELEGRAM_SERVER_IP) |
                                        .telegram.server.port = env(TELEGRAM_SERVER_PORT) |
                                        .telegram.proxy.type = env(TELEGRAM_PROXY_TYPE) |
                                        .telegram.proxy.address = env(TELEGRAM_PROXY_ADDRESS) |
                                        .telegram.proxy.port = env(TELEGRAM_PROXY_PORT) |
                                        .telegram.proxy.rdns = env(TELEGRAM_PROXY_RDNS) |
                                        .telegram.proxy.username = env(TELEGRAM_PROXY_USER) |
                                        .telegram.proxy.password = env(TELEGRAM_PROXY_PASS)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        case "${TELEGRAM_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_telegram "${TELEGRAM_LOG_PATH}"/"${TELEGRAM_LOG_FILE}" bridge_ matrix matrixtelegram
                export TELEGRAM_LOG_TYPE="console,file"
            ;;
            "console" )
                export TELEGRAM_LOG_TYPE="console"
            ;;
            "file" )
                create_logrotate bridge_telegram "${TELEGRAM_LOG_PATH}"/"${TELEGRAM_LOG_FILE}" bridge_ matrix matrixtelegram
                export TELEGRAM_LOG_TYPE="file"
            ;;
        esac
        # .logging.root.handlers = [ "'$(echo "${TELEGRAM_LOG_TYPE,,//,/\",\"}")'" ]
        s6-setuidgid matrix yq -i   '
                                        .logging.version = 1 |
                                        .logging.handlers.file.class = "logging.FileHandler" |
                                        .logging.handlers.file.filename = "'$(echo "${TELEGRAM_LOG_PATH}/${TELEGRAM_LOG_FILE}")'" |
                                        del(.logging.handlers.file.backupCount) |
                                        del(.logging.handlers.file.maxBytes) |
                                        .logging.loggers.mau.level = env(TELEGRAM_LOG_LEVEL_MAU) |
                                        .logging.loggers.telethon.level = env(TELEGRAM_LOG_LEVEL_TELETHON) |
                                        .logging.loggers.aiohttp.level = env(TELEGRAM_LOG_LEVEL_AIOHTTP) |
                                        .logging.root.level = env(TELEGRAM_LOG_LEVEL)
                                    ' "${TELEGRAM_CONFIG_PATH}"/"${TELEGRAM_CONFIG_FILE}"

        if [ ! -f "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_telegram] Didn't find a registration file. Generating to '${TELEGRAM_REGISTRATION_PATH}/${TELEGRAM_REGISTRATION_FILE}'"
            telegram_generate_registration=true
        elif var_true "${TELEGRAM_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_telegram] Regenerating registration file to '${TELEGRAM_REGISTRATION_PATH}/${TELEGRAM_REGISTRATION_FILE}'"
            telegram_generate_registration=true
        elif var_true "${telegram_force_registration}" ; then
            print_notice "[configure_telegram] Something has changed  - Force generating registration file to '${TELEGRAM_REGISTRATION_PATH}/${TELEGRAM_REGISTRATION_FILE}'"
            telegram_generate_registration=true
        fi

        if var_true "${telegram_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${TELEGRAM_REGISTRATION_PATH}"
            s6-setuidgid matrix python3 -m mautrix_telegram \
                                                        -g \
                                                        -c "${TELEGRAM_CONFIG_PATH}"/${TELEGRAM_CONFIG_FILE} \
                                                        -r "${TELEGRAM_REGISTRATION_PATH}"/"${TELEGRAM_REGISTRATION_FILE}" \
                                                        || exit $?
            print_notice "[configure_telegram] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

configure_whatsapp() {
    if [ "${SETUP_TYPE,,}" = "auto" ] ; then
        set -a
        source /assets/defaults/bridge_whatsapp
        set +a
        print_debug "[configure_whatsapp]"

        if [ ! -d "${WHATSAPP_CONFIG_PATH}" ] ; then
            mkdir -p "${WHATSAPP_CONFIG_PATH}"
        fi
        if [ $(stat -c %U "${WHATSAPP_CONFIG_PATH}") != "matrix" ] ; then chown matrix:matrix "${WHATSAPP_CONFIG_PATH}" ; fi

        if [ ! -d "${WHATSAPP_REGISTRATION_PATH}" ] ; then
            mkdir -p "${WHATSAPP_REGISTRATION_PATH}"
        fi
        if [ $(stat -c %U "${WHATSAPP_REGISTRATION_PATH}") != "matrix" ] ; then chown matrix:matrix "${WHATSAPP_REGISTRATION_PATH}" ; fi

        if [ ! -d "${WHATSAPP_LOG_PATH}" ] ; then
            mkdir -p "${WHATSAPP_LOG_PATH}"
        fi
        if [ $(stat -c %U "${WHATSAPP_LOG_PATH}") != "matrix" ] ; then chown matrix:matrix "${WHATSAPP_LOG_PATH}" ; fi

        case "${WHATSAPP_DB_TYPE,,}" in
            postgres* )
                sanity_var WHATSAPP_DB_USER "DB Username for Whatsapp"
                sanity_var WHATSAPP_DB_PASS "DB Password for Whatsapp"
                sanity_var WHATSAPP_DB_HOST "DB Host for Whatsapp"
                sanity_var WHATSAPP_DB_NAME "DB Name for Whatsapp"
                counter=0
                export PGPASSWORD=${WHATSAPP_DB_PASS}
                until pg_isready --dbname="${WHATSAPP_DB_NAME}" --host="${WHATSAPP_DB_HOST}" --port="${WHATSAPP_DB_PORT}" --username="${WHATSAPP_DB_USER}" -q ; do
                    sleep 5
                    (( counter+=5 ))
                    print_warn "Postgres Host '${WHATSAPP_DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
                done
                if var_true "${WHATSAPP_DB_ENABLE_TLS}" ; then
                    whatsapp_db_tls="?sslmode=enable"
                else
                    whatsapp_db_tls="?sslmode=disable"
                fi
                export WHATSAPP_DB_TYPE=postgres
                export WHATSAPP_DB_STRING=${WHATSAPP_DB_STRING:-"postgres://${WHATSAPP_DB_USER}:${WHATSAPP_DB_PASS}@${WHATSAPP_DB_HOST}:${WHATSAPP_DB_PORT}/${WHATSAPP_DB_NAME}${whatsapp_db_tls}"}
            ;;
            sqlite* )
                if [ ! -d "${WHATSAPP_DB_SQLITE_PATH}" ] ; then
                    mkdir -p "${WHATSAPP_DB_SQLITE_PATH}"
                fi
                if [ $(stat -c %U "${WHATSAPP_DB_SQLITE_PATH}") != "matrix" ] ; then chown matrix:matrix "${WHATSAPP_DB_SQLITE_PATH}" ; fi
                export WHATSAPP_DB_TYPE=sqlite-fk-wal
                export WHATSAPP_DB_STRING=${WHATSAPP_DB_STRING:-"file://${WHATSAPP_DB_SQLITE_PATH}/${WHATSAPP_DB_SQLITE_FILE}?_txlock=immediate"}
            ;;
        esac

        if [ ! -f "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}" ]; then
            s6-setuidgid matrix cp -R /assets/config/whatsapp/example.config.yaml "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .homeserver.address = env(WHATSAPP_HOMESERVER_ADDRESS) |
                                        .homeserver.domain = env(WHATSAPP_HOMESERVER_DOMAIN) |
                                        .homeserver.software = env(WHATSAPP_HOMESERVER_SOFTWARE) |
                                        .homeserver.status_endpoint = env(WHATSAPP_HOMESERVER_STATUS_ENDPOINT) |
                                        .homeserver.message_send_checkpoint_endpoint = env(WHATSAPP_HOMESERVER_MESSAGE_SEND_CHECKPOINT_ENDPOINT) |
                                        .homeserver.async_media = env(WHATSAPP_HOMESERVER_ENABLE_ASYNC_UPLOADS)
                                    ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .appservice.address = env(WHATSAPP_APPSERVER_ADDRESS) |
                                        .appservice.hostname = env(WHATSAPP_LISTEN_IP) |
                                        .appservice.port = env(WHATSAPP_LISTEN_PORT) |
                                        .appservice.database.type = env(WHATSAPP_DB_TYPE) |
                                        .appservice.database.uri = env(WHATSAPP_DB_STRING) |
                                        .appservice.database.max_open_conns = env(WHATSAPP_DB_CONNECTIONS_MAX_OPEN) |
                                        .appservice.database.max_idle_conns = env(WHATSAPP_DB_CONNECTIONS_MAX_IDLE) |
                                        .appservice.database.max_conn_idle_time = env(WHATSAPP_DB_CONNECTIONS_MAX_IDLE_LIFETIME) |
                                        .appservice.database.max_conn_lifetime = env(WHATSAPP_DB_CONNECTIONS_MAX_LIFETIME) |
                                        .appservice.id = env(WHATSAPP_APPSERVICE_ID) |
                                        .appservice.bot_username = env(WHATSAPP_BOT_USERNAME) |
                                        .appservice.bot_displayname = env(WHATSAPP_BOT_DISPLAYNAME) |
                                        .appservice.bot_avatar = env(WHATSAPP_BOT_AVATAR) |
                                        .appservice.ephemeral_events = env(WHATSAPP_ENABLE_EPHEMERAL_EVENTS) |
                                        .appservice.async_transactions = env(WHATSAPP_ENABLE_ASYNC_TRANSACTIONS)
                                    ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"


        if [ -f "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}" && [ -z "${WHATSAPP_AS_TOKEN}" ] ; then
            print_debug "[configure_whatsapp] Setting as_token in configuration from previously generated registration file"
            export TOI_WHATSAPP_AS_TOKEN=$(yq '.as_token' "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(TOI_WHATSAPP_AS_TOKEN)
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            waastokenskip=true
        elif [ -n "${WHATSAPP_AS_TOKEN}" ] && grep -q 'as_token: "This value is generated when generating the registration"' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"; then
            print_notice "You've supplied 'WHATSAPP_AS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${WHATSAPP_AS_TOKEN}" ] ; then
            print_debug "[configure_whatsapp] Updating WHATSAPP_AS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.as_token = env(WHATSAPP_AS_TOKEN)
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        fi

        if [ -f "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}" && [ -z "${WHATSAPP_HS_TOKEN}" ] ; then
            print_debug "[configure_whatsapp] Setting hs_token in configuration from previously generated registration file"
            export TOI_WHATSAPP_HS_TOKEN=$(yq '.hs_token' "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}")
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(TOI_WHATSAPP_HS_TOKEN)
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            wahstokenskip=true
        elif [ -n "${WHATSAPP_HS_TOKEN}" ] && grep -q 'hs_token: "This value is generated when generating the registration"' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"; then
            print_notice "You've supplied 'WHATSAPP_HS_TOKEN' - It needs to be autogenerated, ignoring for this run. Please update with autogenerated value "
        elif [ -n "${WHATSAPP_HS_TOKEN}" ] ; then
            print_debug "[configure_whatsapp] Updating WHATSAPP_HS_TOKEN"
            s6-setuidgid matrix yq -i   '
                                            .appservice.hs_token = env(WHATSAPP_HS_TOKEN)
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i   '
                                        .metrics.enabled = env(WHATSAPP_ENABLE_METRICS) |
                                        .metrics.listen = "'$(echo ${WHATSAPP_METRICS_LISTEN_IP}:${WHATSAPP_METRICS_LISTEN_PORT})'"
                                    ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"

        s6-setuidgid matrix yq -i   '
                                        .segment_key = env(WHATSAPP_SEGMENT_API_KEY)
                                    ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"

       s6-setuidgid matrix yq -i    '
                                        .whatsapp.os_name = env(WHATSAPP_OS_NAME) |
                                        .whatsapp.browser_name = env(WHATSAPP_BROWSER_NAME)
                                    ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"

        if var_true "${DISCORD_CONFIGURE_BRIDGE}" ; then
            s6-setuidgid matrix yq -i   '
                                            .bridge.username_template = strenv(WHATSAPP_TEMPLATE_USERNAME) |
                                            .bridge.displayname_template = strenv(WHATSAPP_TEMPLATE_DISPLAYNAME) |
                                            .bridge.personal_filtering_spaces = env(WHATSAPP_PERSONAL_FILTERING_SPACES) |
                                            .bridge.delivery_receipts = env(WHATSAPP_ENABLE_DELIVERY_RECEIPTS) |
                                            .bridge.message_status_events = env(WHATSAPP_ENABLE_MESSAGE_STATUS_EVENTS) |
                                            .bridge.message_error_notices = env(WHATSAPP_ENABLE_MESSAGE_ERROR_NOTICES) |
                                            .bridge.call_start_notices = env(WHATSAPP_ENABLE_CALL_START_NOTICES) |
                                            .bridge.identity_change_notices = env(WHATSAPP_ENABLE_IDENTITY_CHANGE_NOTICES) |
                                            .bridge.portal_message_buffer = env(WHATSAPP_PORTAL_MESSAGE_BUFFER) |
                                            .bridge.federate_rooms = env(WHATSAPP_FEDERATE_ROOMS) |
                                            .bridge.command_prefix = "'$(echo ${WHATSAPP_COMMAND_PREFIX})'" |
                                            .bridge.encryption.allow = env(WHATSAPP_ENCRYPTION_ALLOW) |
                                            .bridge.encryption.default = env(WHATSAPP_ENCRYPTION_DEFAULT) |
                                            .bridge.encryption.appservice = env(WHATSAPP_ENCRYPTION_APPSERVICE) |
                                            .bridge.encryption.require = env(WHATSAPP_ENCRYPTION_REQUIRE) |
                                            .bridge.encryption.allow_key_sharing = env(WHATSAPP_ENCRYPTION_ALLOW_KEY_SHARING) |
                                            .bridge.encryption.verification_levels.receive = env(WHATSAPP_ENCRYPTION_VERIFY_LEVELS_RECEIVE) |
                                            .bridge.encryption.verification_levels.send = env(WHATSAPP_ENCRYPTION_VERIFY_LEVELS_SEND) |
                                            .bridge.encryption.verification_levels.share = env(WHATSAPP_ENCRYPTION_VERIFY_LEVELS_SHARE) |
                                            .bridge.encryption.rotation.enable_custom = env(WHATSAPP_ENCRYPTION_ROTATION_ENABLE_CUSTOM) |
                                            .bridge.encryption.rotation.milliseconds = env(WHATSAPP_ENCRYPTION_ROTATION_MILLISECONDS) |
                                            .bridge.encryption.rotation.messages = env(WHATSAPP_ENCRYPTION_ROTATION_MESSAGES)
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        fi
        s6-setuidgid matrix yq -i 'del(.bridge.permissions)' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        set -f

        if [ -n "${WHATSAPP_PERMISSIONS_RELAY}" ] ; then
            warelays=$(echo "${WHATSAPP_PERMISSIONS_RELAY}" | tr "," "\n")
            for warelay in $warelays; do
                if [ "$warelay" = "*" ] ; then
                    export WARELAY="PLACEHOLDERASTERISK"
                else
                    export WARELAY=$warelay
                fi
                s6-setuidgid matrix yq -i    '
                                            .bridge.permissions.[ "'$(echo ${WARELAY})'" ]+= "relay"
                                        ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            done
        fi

        if [ -n "${WHATSAPP_PERMISSIONS_ADMIN}" ] ; then
            waadmins=$(echo "${WHATSAPP_PERMISSIONS_ADMIN}" | tr "," "\n")
            for waadmin in $waadmins; do
                if [ "$waadmin" = "*" ] ; then
                    export WAADMIN="PLACEHOLDERASTERISK"
                else
                    export WAADMIN=$waadmin
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[ "'$(echo ${WAADMIN})'" ] += "admin"
                                            ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            done
        fi

        if [ -n "${WHATSAPP_PERMISSIONS_USER}" ] ; then
            wausers=$(echo "${WHATSAPP_PERMISSIONS_USER}" | tr "," "\n")
            for wauser in $wausers; do
                if [ "$wauser" = "*" ] ; then
                    export WAUSER="PLACEHOLDERASTERISK"
                else
                    export WAUSER=$wauser
                fi
                s6-setuidgid matrix yq -i   '
                                                .bridge.permissions.[env(WAUSER)] += "user"
                                            ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            done
        fi
        set +f
        if grep -q "PLACEHOLDERASTERISK" "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}" ; then
            s6-setuidgid matrix sed -i "s|PLACEHOLDERASTERISK|\"*\"|g" "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        fi

        s6-setuidgid matrix yq -i 'del(.logging)' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
        yq -i '.logging.min_level = env(WHATSAPP_LOG_LEVEL)' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"

        case "${WHATSAPP_LOG_TYPE,,}" in
            "both" )
                create_logrotate bridge_whatsapp "${WHATSAPP_LOG_PATH}"/"${WHATSAPP_LOG_FILE}" bridge_ matrix matrixwhatsapp
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            },
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${WHATSAPP_LOG_PATH}/${WHATSAPP_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            ;;
            "console" )
                yq -i '
                        .logging.writers = [
                            {
                                "type": "stdout",
                                "format": "pretty-colored"
                            }
                        ]
                      ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            ;;
            "file" )
                create_logrotate bridge_whatsapp "${WHATSAPP_LOG_PATH}"/"${WHATSAPP_LOG_FILE}" bridge_ matrix matrixwhatsapp
                yq -i '
                        .logging.writers = [
                            {
                                "type": "file",
                                "format": "json",
                                "filename": "'$(echo "${WHATSAPP_LOG_PATH}/${WHATSAPP_LOG_FILE}")'",
                                "max_size": 0,
                                "local_time": true
                            }
                        ]
                      ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
            ;;
        esac

        #case "${WHATSAPP_LOG_TYPE,,}" in
        #    "both" )
        #        create_logrotate bridge_whatsapp "${WHATSAPP_LOG_PATH}"/"${WHATSAPP_LOG_FILE}" bridge_ matrix matrixwhatsapp
        #        export WHATSAPP_LOG_TYPE="console,file"
        #    ;;
        #    "console" )
        #        export WHATSAPP_LOG_TYPE="console"
        #        export WHATSAPP_LOG_FILE="null"
        #    ;;
        #    "file" )
        #        create_logrotate bridge_whatsapp "${WHATSAPP_LOG_PATH}"/"${WHATSAPP_LOG_FILE}" bridge_ matrix matrixwhatsapp
        #        export WHATSAPP_LOG_TYPE="file"
        #    ;;
        #esac
#
        #s6-setuidgid matrix yq -i   '
        #                                .logging.directory = "'$(echo "${WHATSAPP_LOG_PATH}")'" |
        #                                .logging.file_name_format = env(WHATSAPP_LOG_FILE) |
        #                                .logging.print_level = env(WHATSAPP_LOG_LEVEL) |
        #                                .logging.root.handlers = [ "'$(echo "${WHATSAPP_LOG_TYPE,,//,/\",\"}")'" ] |
        #                                .logging.file_mode = "0o777" |
        #                                .logging.timestamp_format = "2006-01-02 15:04:05"
        #                            ' "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}"
#
        #create_logrotate bridge_whatsapp "${WHATSAPP_LOG_PATH}"/"${WHATSAPP_LOG_FILE}" bridge_ matrix matrixwhatsapp

        if [ ! -f "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}" ] ; then
            print_notice "[configure_whatsapp] Didn't find a registration file. Generating to '${WHATSAPP_REGISTRATION_PATH}/${WHATSAPP_REGISTRATION_FILE}'"
            wa_generate_registration=true
        elif var_true "${WHATSAPP_REGENERATE_REGISTRATION}" ; then
            print_notice "[configure_whatsapp] Regenerating registration file to '${WHATSAPP_REGISTRATION_PATH}/${WHATSAPP_REGISTRATION_FILE}'"
            wa_generate_registration=true
        elif var_true "${wa_force_registration}" ; then
            print_notice "[configure_whatsapp] Something has changed  - Force generating registration file to '${WHATSAPP_REGISTRATION_PATH}/${WHATSAPP_REGISTRATION_FILE}'"
            wa_generate_registration=true
        fi

        if var_true "${wa_generate_registration}" ; then
            s6-setuidgid matrix mkdir -p "${WHATSAPP_REGISTRATION_PATH}"
            silent s6-setuidgid matrix mautrix-whatsapp \
                                                    -g \
                                                    -c "${WHATSAPP_CONFIG_PATH}"/"${WHATSAPP_CONFIG_FILE}" \
                                                    -r "${WHATSAPP_REGISTRATION_PATH}"/"${WHATSAPP_REGISTRATION_FILE}" \
                                                    || exit $?
            print_notice "[configure_whatsapp] See https://docs.mau.fi/bridges/general/registering-appservices.html to add to your homeserver"
        fi
    fi
}

setup_bridges() {
    if [ -f "/tmp/.container/matrix_bridges/.bridge-env" ]; then
        print_debug "[setup_bridges] Importing BRIDGE environment generated variables"
        source /tmp/.container/matrix_bridges/.bridge-env
    else
        mkdir -p /tmp/.container/matrix_bridges/
        if [ "${MODE,,}" = "ALL" ] ; then
            print_debug "[setup_container_mode] Container Mode: ALL"
            print_debug "[setup_container_mode] Creating BRIDGE environment generated variables"
            ENABLE_DISCORD=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_FACEBOOK=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_FEEDS=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_FIGMA=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_GITHUB=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_GITLAB=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_HOOKSHOT=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_INSTAGRAM=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_JIRA=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_SIGNAL=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_SLACK=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_TELEGRAM=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_WEBHOOKS=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
            ENABLE_WHATSAPP=TRUE >> /tmp/.container/matrix_bridges/.bridge-env
        else
            modes=$(echo "${MODE,,}" | tr "," "\n")
            for mode in $modes
            do
                case "${mode,,}" in
                    "discord")
                        echo "ENABLE_DISCORD=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "facebook")
                        echo "ENABLE_FACEBOOK=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "feeds" | "rss" | "atom" )
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_FEEDS=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "figma" )
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_FEEDS=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "github" )
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_GITHUB=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "gitlab" )
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_GITLAB=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "google*")
                        echo "ENABLE_GOOGLECHAT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "hookshot" )
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "instagram")
                        echo "ENABLE_INSTAGRAM=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "jira")
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_JIRA=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "signal")
                        echo "ENABLE_SIGNAL=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "slack")
                        echo "ENABLE_SLACK=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "telegram")
                        echo "ENABLE_TELEGRAM=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "webhooks")
                        echo "ENABLE_HOOKSHOT=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                        echo "ENABLE_WEBHOOKS=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    "whatsapp")
                        echo "ENABLE_WHATSAPP=TRUE" >> /tmp/.container/matrix_bridges/.bridge-env
                    ;;
                    *)
                        print_error "[setup_bridges] Unknown 'BRIDGE' environment variable - exitting.."
                        exit 1
                    ;;
                esac
            done
        fi
        source /tmp/.container/matrix_bridges/.bridge-env
    fi
}
